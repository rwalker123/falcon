// automatically generated by the FlatBuffers compiler, do not modify

// @generated

use core::cmp::Ordering;
use core::mem;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[allow(unused_imports, dead_code)]
pub mod shadow_scale {

    use core::cmp::Ordering;
    use core::mem;

    extern crate flatbuffers;
    use self::flatbuffers::{EndianScalar, Follow};
    #[allow(unused_imports, dead_code)]
    pub mod sim {

        use core::cmp::Ordering;
        use core::mem;

        extern crate flatbuffers;
        use self::flatbuffers::{EndianScalar, Follow};

        #[deprecated(
            since = "2.0.0",
            note = "Use associated constants instead. This will no longer be generated in 2021."
        )]
        pub const ENUM_MIN_INFLUENCE_DOMAIN: u8 = 0;
        #[deprecated(
            since = "2.0.0",
            note = "Use associated constants instead. This will no longer be generated in 2021."
        )]
        pub const ENUM_MAX_INFLUENCE_DOMAIN: u8 = 4;
        #[deprecated(
            since = "2.0.0",
            note = "Use associated constants instead. This will no longer be generated in 2021."
        )]
        #[allow(non_camel_case_types)]
        pub const ENUM_VALUES_INFLUENCE_DOMAIN: [InfluenceDomain; 5] = [
            InfluenceDomain::Sentiment,
            InfluenceDomain::Discovery,
            InfluenceDomain::Logistics,
            InfluenceDomain::Production,
            InfluenceDomain::Humanitarian,
        ];

        #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
        #[repr(transparent)]
        pub struct InfluenceDomain(pub u8);
        #[allow(non_upper_case_globals)]
        impl InfluenceDomain {
            pub const Sentiment: Self = Self(0);
            pub const Discovery: Self = Self(1);
            pub const Logistics: Self = Self(2);
            pub const Production: Self = Self(3);
            pub const Humanitarian: Self = Self(4);

            pub const ENUM_MIN: u8 = 0;
            pub const ENUM_MAX: u8 = 4;
            pub const ENUM_VALUES: &'static [Self] = &[
                Self::Sentiment,
                Self::Discovery,
                Self::Logistics,
                Self::Production,
                Self::Humanitarian,
            ];
            /// Returns the variant's name or "" if unknown.
            pub fn variant_name(self) -> Option<&'static str> {
                match self {
                    Self::Sentiment => Some("Sentiment"),
                    Self::Discovery => Some("Discovery"),
                    Self::Logistics => Some("Logistics"),
                    Self::Production => Some("Production"),
                    Self::Humanitarian => Some("Humanitarian"),
                    _ => None,
                }
            }
        }
        impl core::fmt::Debug for InfluenceDomain {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                if let Some(name) = self.variant_name() {
                    f.write_str(name)
                } else {
                    f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
                }
            }
        }
        impl<'a> flatbuffers::Follow<'a> for InfluenceDomain {
            type Inner = Self;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                let b = unsafe { flatbuffers::read_scalar_at::<u8>(buf, loc) };
                Self(b)
            }
        }

        impl flatbuffers::Push for InfluenceDomain {
            type Output = InfluenceDomain;
            #[inline]
            unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
                unsafe {
                    flatbuffers::emplace_scalar::<u8>(dst, self.0);
                }
            }
        }

        impl flatbuffers::EndianScalar for InfluenceDomain {
            type Scalar = u8;
            #[inline]
            fn to_little_endian(self) -> u8 {
                self.0.to_le()
            }
            #[inline]
            #[allow(clippy::wrong_self_convention)]
            fn from_little_endian(v: u8) -> Self {
                let b = u8::from_le(v);
                Self(b)
            }
        }

        impl<'a> flatbuffers::Verifiable for InfluenceDomain {
            #[inline]
            fn run_verifier(
                v: &mut flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                u8::run_verifier(v, pos)
            }
        }

        impl flatbuffers::SimpleToVerifyInSlice for InfluenceDomain {}
        #[deprecated(
            since = "2.0.0",
            note = "Use associated constants instead. This will no longer be generated in 2021."
        )]
        pub const ENUM_MIN_INFLUENCE_SCOPE_KIND: u8 = 0;
        #[deprecated(
            since = "2.0.0",
            note = "Use associated constants instead. This will no longer be generated in 2021."
        )]
        pub const ENUM_MAX_INFLUENCE_SCOPE_KIND: u8 = 3;
        #[deprecated(
            since = "2.0.0",
            note = "Use associated constants instead. This will no longer be generated in 2021."
        )]
        #[allow(non_camel_case_types)]
        pub const ENUM_VALUES_INFLUENCE_SCOPE_KIND: [InfluenceScopeKind; 4] = [
            InfluenceScopeKind::Local,
            InfluenceScopeKind::Regional,
            InfluenceScopeKind::Global,
            InfluenceScopeKind::Generation,
        ];

        #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
        #[repr(transparent)]
        pub struct InfluenceScopeKind(pub u8);
        #[allow(non_upper_case_globals)]
        impl InfluenceScopeKind {
            pub const Local: Self = Self(0);
            pub const Regional: Self = Self(1);
            pub const Global: Self = Self(2);
            pub const Generation: Self = Self(3);

            pub const ENUM_MIN: u8 = 0;
            pub const ENUM_MAX: u8 = 3;
            pub const ENUM_VALUES: &'static [Self] =
                &[Self::Local, Self::Regional, Self::Global, Self::Generation];
            /// Returns the variant's name or "" if unknown.
            pub fn variant_name(self) -> Option<&'static str> {
                match self {
                    Self::Local => Some("Local"),
                    Self::Regional => Some("Regional"),
                    Self::Global => Some("Global"),
                    Self::Generation => Some("Generation"),
                    _ => None,
                }
            }
        }
        impl core::fmt::Debug for InfluenceScopeKind {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                if let Some(name) = self.variant_name() {
                    f.write_str(name)
                } else {
                    f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
                }
            }
        }
        impl<'a> flatbuffers::Follow<'a> for InfluenceScopeKind {
            type Inner = Self;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                let b = unsafe { flatbuffers::read_scalar_at::<u8>(buf, loc) };
                Self(b)
            }
        }

        impl flatbuffers::Push for InfluenceScopeKind {
            type Output = InfluenceScopeKind;
            #[inline]
            unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
                unsafe {
                    flatbuffers::emplace_scalar::<u8>(dst, self.0);
                }
            }
        }

        impl flatbuffers::EndianScalar for InfluenceScopeKind {
            type Scalar = u8;
            #[inline]
            fn to_little_endian(self) -> u8 {
                self.0.to_le()
            }
            #[inline]
            #[allow(clippy::wrong_self_convention)]
            fn from_little_endian(v: u8) -> Self {
                let b = u8::from_le(v);
                Self(b)
            }
        }

        impl<'a> flatbuffers::Verifiable for InfluenceScopeKind {
            #[inline]
            fn run_verifier(
                v: &mut flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                u8::run_verifier(v, pos)
            }
        }

        impl flatbuffers::SimpleToVerifyInSlice for InfluenceScopeKind {}
        #[deprecated(
            since = "2.0.0",
            note = "Use associated constants instead. This will no longer be generated in 2021."
        )]
        pub const ENUM_MIN_INFLUENCE_LIFECYCLE: u8 = 0;
        #[deprecated(
            since = "2.0.0",
            note = "Use associated constants instead. This will no longer be generated in 2021."
        )]
        pub const ENUM_MAX_INFLUENCE_LIFECYCLE: u8 = 2;
        #[deprecated(
            since = "2.0.0",
            note = "Use associated constants instead. This will no longer be generated in 2021."
        )]
        #[allow(non_camel_case_types)]
        pub const ENUM_VALUES_INFLUENCE_LIFECYCLE: [InfluenceLifecycle; 3] = [
            InfluenceLifecycle::Potential,
            InfluenceLifecycle::Active,
            InfluenceLifecycle::Dormant,
        ];

        #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
        #[repr(transparent)]
        pub struct InfluenceLifecycle(pub u8);
        #[allow(non_upper_case_globals)]
        impl InfluenceLifecycle {
            pub const Potential: Self = Self(0);
            pub const Active: Self = Self(1);
            pub const Dormant: Self = Self(2);

            pub const ENUM_MIN: u8 = 0;
            pub const ENUM_MAX: u8 = 2;
            pub const ENUM_VALUES: &'static [Self] =
                &[Self::Potential, Self::Active, Self::Dormant];
            /// Returns the variant's name or "" if unknown.
            pub fn variant_name(self) -> Option<&'static str> {
                match self {
                    Self::Potential => Some("Potential"),
                    Self::Active => Some("Active"),
                    Self::Dormant => Some("Dormant"),
                    _ => None,
                }
            }
        }
        impl core::fmt::Debug for InfluenceLifecycle {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                if let Some(name) = self.variant_name() {
                    f.write_str(name)
                } else {
                    f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
                }
            }
        }
        impl<'a> flatbuffers::Follow<'a> for InfluenceLifecycle {
            type Inner = Self;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                let b = unsafe { flatbuffers::read_scalar_at::<u8>(buf, loc) };
                Self(b)
            }
        }

        impl flatbuffers::Push for InfluenceLifecycle {
            type Output = InfluenceLifecycle;
            #[inline]
            unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
                unsafe {
                    flatbuffers::emplace_scalar::<u8>(dst, self.0);
                }
            }
        }

        impl flatbuffers::EndianScalar for InfluenceLifecycle {
            type Scalar = u8;
            #[inline]
            fn to_little_endian(self) -> u8 {
                self.0.to_le()
            }
            #[inline]
            #[allow(clippy::wrong_self_convention)]
            fn from_little_endian(v: u8) -> Self {
                let b = u8::from_le(v);
                Self(b)
            }
        }

        impl<'a> flatbuffers::Verifiable for InfluenceLifecycle {
            #[inline]
            fn run_verifier(
                v: &mut flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                u8::run_verifier(v, pos)
            }
        }

        impl flatbuffers::SimpleToVerifyInSlice for InfluenceLifecycle {}
        #[deprecated(
            since = "2.0.0",
            note = "Use associated constants instead. This will no longer be generated in 2021."
        )]
        pub const ENUM_MIN_CULTURE_LAYER_SCOPE: u8 = 0;
        #[deprecated(
            since = "2.0.0",
            note = "Use associated constants instead. This will no longer be generated in 2021."
        )]
        pub const ENUM_MAX_CULTURE_LAYER_SCOPE: u8 = 2;
        #[deprecated(
            since = "2.0.0",
            note = "Use associated constants instead. This will no longer be generated in 2021."
        )]
        #[allow(non_camel_case_types)]
        pub const ENUM_VALUES_CULTURE_LAYER_SCOPE: [CultureLayerScope; 3] = [
            CultureLayerScope::Global,
            CultureLayerScope::Regional,
            CultureLayerScope::Local,
        ];

        #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
        #[repr(transparent)]
        pub struct CultureLayerScope(pub u8);
        #[allow(non_upper_case_globals)]
        impl CultureLayerScope {
            pub const Global: Self = Self(0);
            pub const Regional: Self = Self(1);
            pub const Local: Self = Self(2);

            pub const ENUM_MIN: u8 = 0;
            pub const ENUM_MAX: u8 = 2;
            pub const ENUM_VALUES: &'static [Self] = &[Self::Global, Self::Regional, Self::Local];
            /// Returns the variant's name or "" if unknown.
            pub fn variant_name(self) -> Option<&'static str> {
                match self {
                    Self::Global => Some("Global"),
                    Self::Regional => Some("Regional"),
                    Self::Local => Some("Local"),
                    _ => None,
                }
            }
        }
        impl core::fmt::Debug for CultureLayerScope {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                if let Some(name) = self.variant_name() {
                    f.write_str(name)
                } else {
                    f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
                }
            }
        }
        impl<'a> flatbuffers::Follow<'a> for CultureLayerScope {
            type Inner = Self;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                let b = unsafe { flatbuffers::read_scalar_at::<u8>(buf, loc) };
                Self(b)
            }
        }

        impl flatbuffers::Push for CultureLayerScope {
            type Output = CultureLayerScope;
            #[inline]
            unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
                unsafe {
                    flatbuffers::emplace_scalar::<u8>(dst, self.0);
                }
            }
        }

        impl flatbuffers::EndianScalar for CultureLayerScope {
            type Scalar = u8;
            #[inline]
            fn to_little_endian(self) -> u8 {
                self.0.to_le()
            }
            #[inline]
            #[allow(clippy::wrong_self_convention)]
            fn from_little_endian(v: u8) -> Self {
                let b = u8::from_le(v);
                Self(b)
            }
        }

        impl<'a> flatbuffers::Verifiable for CultureLayerScope {
            #[inline]
            fn run_verifier(
                v: &mut flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                u8::run_verifier(v, pos)
            }
        }

        impl flatbuffers::SimpleToVerifyInSlice for CultureLayerScope {}
        #[deprecated(
            since = "2.0.0",
            note = "Use associated constants instead. This will no longer be generated in 2021."
        )]
        pub const ENUM_MIN_CULTURE_TRAIT_AXIS: u8 = 0;
        #[deprecated(
            since = "2.0.0",
            note = "Use associated constants instead. This will no longer be generated in 2021."
        )]
        pub const ENUM_MAX_CULTURE_TRAIT_AXIS: u8 = 14;
        #[deprecated(
            since = "2.0.0",
            note = "Use associated constants instead. This will no longer be generated in 2021."
        )]
        #[allow(non_camel_case_types)]
        pub const ENUM_VALUES_CULTURE_TRAIT_AXIS: [CultureTraitAxis; 15] = [
            CultureTraitAxis::PassiveAggressive,
            CultureTraitAxis::OpenClosed,
            CultureTraitAxis::CollectivistIndividualist,
            CultureTraitAxis::TraditionalistRevisionist,
            CultureTraitAxis::HierarchicalEgalitarian,
            CultureTraitAxis::SyncreticPurist,
            CultureTraitAxis::AsceticIndulgent,
            CultureTraitAxis::PragmaticIdealistic,
            CultureTraitAxis::RationalistMystical,
            CultureTraitAxis::ExpansionistInsular,
            CultureTraitAxis::AdaptiveStubborn,
            CultureTraitAxis::HonorBoundOpportunistic,
            CultureTraitAxis::MeritOrientedLineageOriented,
            CultureTraitAxis::SecularDevout,
            CultureTraitAxis::PluralisticMonocultural,
        ];

        #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
        #[repr(transparent)]
        pub struct CultureTraitAxis(pub u8);
        #[allow(non_upper_case_globals)]
        impl CultureTraitAxis {
            pub const PassiveAggressive: Self = Self(0);
            pub const OpenClosed: Self = Self(1);
            pub const CollectivistIndividualist: Self = Self(2);
            pub const TraditionalistRevisionist: Self = Self(3);
            pub const HierarchicalEgalitarian: Self = Self(4);
            pub const SyncreticPurist: Self = Self(5);
            pub const AsceticIndulgent: Self = Self(6);
            pub const PragmaticIdealistic: Self = Self(7);
            pub const RationalistMystical: Self = Self(8);
            pub const ExpansionistInsular: Self = Self(9);
            pub const AdaptiveStubborn: Self = Self(10);
            pub const HonorBoundOpportunistic: Self = Self(11);
            pub const MeritOrientedLineageOriented: Self = Self(12);
            pub const SecularDevout: Self = Self(13);
            pub const PluralisticMonocultural: Self = Self(14);

            pub const ENUM_MIN: u8 = 0;
            pub const ENUM_MAX: u8 = 14;
            pub const ENUM_VALUES: &'static [Self] = &[
                Self::PassiveAggressive,
                Self::OpenClosed,
                Self::CollectivistIndividualist,
                Self::TraditionalistRevisionist,
                Self::HierarchicalEgalitarian,
                Self::SyncreticPurist,
                Self::AsceticIndulgent,
                Self::PragmaticIdealistic,
                Self::RationalistMystical,
                Self::ExpansionistInsular,
                Self::AdaptiveStubborn,
                Self::HonorBoundOpportunistic,
                Self::MeritOrientedLineageOriented,
                Self::SecularDevout,
                Self::PluralisticMonocultural,
            ];
            /// Returns the variant's name or "" if unknown.
            pub fn variant_name(self) -> Option<&'static str> {
                match self {
                    Self::PassiveAggressive => Some("PassiveAggressive"),
                    Self::OpenClosed => Some("OpenClosed"),
                    Self::CollectivistIndividualist => Some("CollectivistIndividualist"),
                    Self::TraditionalistRevisionist => Some("TraditionalistRevisionist"),
                    Self::HierarchicalEgalitarian => Some("HierarchicalEgalitarian"),
                    Self::SyncreticPurist => Some("SyncreticPurist"),
                    Self::AsceticIndulgent => Some("AsceticIndulgent"),
                    Self::PragmaticIdealistic => Some("PragmaticIdealistic"),
                    Self::RationalistMystical => Some("RationalistMystical"),
                    Self::ExpansionistInsular => Some("ExpansionistInsular"),
                    Self::AdaptiveStubborn => Some("AdaptiveStubborn"),
                    Self::HonorBoundOpportunistic => Some("HonorBoundOpportunistic"),
                    Self::MeritOrientedLineageOriented => Some("MeritOrientedLineageOriented"),
                    Self::SecularDevout => Some("SecularDevout"),
                    Self::PluralisticMonocultural => Some("PluralisticMonocultural"),
                    _ => None,
                }
            }
        }
        impl core::fmt::Debug for CultureTraitAxis {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                if let Some(name) = self.variant_name() {
                    f.write_str(name)
                } else {
                    f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
                }
            }
        }
        impl<'a> flatbuffers::Follow<'a> for CultureTraitAxis {
            type Inner = Self;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                let b = unsafe { flatbuffers::read_scalar_at::<u8>(buf, loc) };
                Self(b)
            }
        }

        impl flatbuffers::Push for CultureTraitAxis {
            type Output = CultureTraitAxis;
            #[inline]
            unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
                unsafe {
                    flatbuffers::emplace_scalar::<u8>(dst, self.0);
                }
            }
        }

        impl flatbuffers::EndianScalar for CultureTraitAxis {
            type Scalar = u8;
            #[inline]
            fn to_little_endian(self) -> u8 {
                self.0.to_le()
            }
            #[inline]
            #[allow(clippy::wrong_self_convention)]
            fn from_little_endian(v: u8) -> Self {
                let b = u8::from_le(v);
                Self(b)
            }
        }

        impl<'a> flatbuffers::Verifiable for CultureTraitAxis {
            #[inline]
            fn run_verifier(
                v: &mut flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                u8::run_verifier(v, pos)
            }
        }

        impl flatbuffers::SimpleToVerifyInSlice for CultureTraitAxis {}
        #[deprecated(
            since = "2.0.0",
            note = "Use associated constants instead. This will no longer be generated in 2021."
        )]
        pub const ENUM_MIN_CULTURE_TENSION_KIND: u8 = 0;
        #[deprecated(
            since = "2.0.0",
            note = "Use associated constants instead. This will no longer be generated in 2021."
        )]
        pub const ENUM_MAX_CULTURE_TENSION_KIND: u8 = 2;
        #[deprecated(
            since = "2.0.0",
            note = "Use associated constants instead. This will no longer be generated in 2021."
        )]
        #[allow(non_camel_case_types)]
        pub const ENUM_VALUES_CULTURE_TENSION_KIND: [CultureTensionKind; 3] = [
            CultureTensionKind::DriftWarning,
            CultureTensionKind::AssimilationPush,
            CultureTensionKind::SchismRisk,
        ];

        #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
        #[repr(transparent)]
        pub struct CultureTensionKind(pub u8);
        #[allow(non_upper_case_globals)]
        impl CultureTensionKind {
            pub const DriftWarning: Self = Self(0);
            pub const AssimilationPush: Self = Self(1);
            pub const SchismRisk: Self = Self(2);

            pub const ENUM_MIN: u8 = 0;
            pub const ENUM_MAX: u8 = 2;
            pub const ENUM_VALUES: &'static [Self] =
                &[Self::DriftWarning, Self::AssimilationPush, Self::SchismRisk];
            /// Returns the variant's name or "" if unknown.
            pub fn variant_name(self) -> Option<&'static str> {
                match self {
                    Self::DriftWarning => Some("DriftWarning"),
                    Self::AssimilationPush => Some("AssimilationPush"),
                    Self::SchismRisk => Some("SchismRisk"),
                    _ => None,
                }
            }
        }
        impl core::fmt::Debug for CultureTensionKind {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                if let Some(name) = self.variant_name() {
                    f.write_str(name)
                } else {
                    f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
                }
            }
        }
        impl<'a> flatbuffers::Follow<'a> for CultureTensionKind {
            type Inner = Self;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                let b = unsafe { flatbuffers::read_scalar_at::<u8>(buf, loc) };
                Self(b)
            }
        }

        impl flatbuffers::Push for CultureTensionKind {
            type Output = CultureTensionKind;
            #[inline]
            unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
                unsafe {
                    flatbuffers::emplace_scalar::<u8>(dst, self.0);
                }
            }
        }

        impl flatbuffers::EndianScalar for CultureTensionKind {
            type Scalar = u8;
            #[inline]
            fn to_little_endian(self) -> u8 {
                self.0.to_le()
            }
            #[inline]
            #[allow(clippy::wrong_self_convention)]
            fn from_little_endian(v: u8) -> Self {
                let b = u8::from_le(v);
                Self(b)
            }
        }

        impl<'a> flatbuffers::Verifiable for CultureTensionKind {
            #[inline]
            fn run_verifier(
                v: &mut flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                u8::run_verifier(v, pos)
            }
        }

        impl flatbuffers::SimpleToVerifyInSlice for CultureTensionKind {}
        #[deprecated(
            since = "2.0.0",
            note = "Use associated constants instead. This will no longer be generated in 2021."
        )]
        pub const ENUM_MIN_TERRAIN_TYPE: u16 = 0;
        #[deprecated(
            since = "2.0.0",
            note = "Use associated constants instead. This will no longer be generated in 2021."
        )]
        pub const ENUM_MAX_TERRAIN_TYPE: u16 = 36;
        #[deprecated(
            since = "2.0.0",
            note = "Use associated constants instead. This will no longer be generated in 2021."
        )]
        #[allow(non_camel_case_types)]
        pub const ENUM_VALUES_TERRAIN_TYPE: [TerrainType; 37] = [
            TerrainType::DeepOcean,
            TerrainType::ContinentalShelf,
            TerrainType::InlandSea,
            TerrainType::CoralShelf,
            TerrainType::HydrothermalVentField,
            TerrainType::TidalFlat,
            TerrainType::RiverDelta,
            TerrainType::MangroveSwamp,
            TerrainType::FreshwaterMarsh,
            TerrainType::Floodplain,
            TerrainType::AlluvialPlain,
            TerrainType::PrairieSteppe,
            TerrainType::MixedWoodland,
            TerrainType::BorealTaiga,
            TerrainType::PeatHeath,
            TerrainType::HotDesertErg,
            TerrainType::RockyReg,
            TerrainType::SemiAridScrub,
            TerrainType::SaltFlat,
            TerrainType::OasisBasin,
            TerrainType::Tundra,
            TerrainType::PeriglacialSteppe,
            TerrainType::Glacier,
            TerrainType::SeasonalSnowfield,
            TerrainType::RollingHills,
            TerrainType::HighPlateau,
            TerrainType::AlpineMountain,
            TerrainType::KarstHighland,
            TerrainType::CanyonBadlands,
            TerrainType::ActiveVolcanoSlope,
            TerrainType::BasalticLavaField,
            TerrainType::AshPlain,
            TerrainType::FumaroleBasin,
            TerrainType::ImpactCraterField,
            TerrainType::KarstCavernMouth,
            TerrainType::SinkholeField,
            TerrainType::AquiferCeiling,
        ];

        #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
        #[repr(transparent)]
        pub struct TerrainType(pub u16);
        #[allow(non_upper_case_globals)]
        impl TerrainType {
            pub const DeepOcean: Self = Self(0);
            pub const ContinentalShelf: Self = Self(1);
            pub const InlandSea: Self = Self(2);
            pub const CoralShelf: Self = Self(3);
            pub const HydrothermalVentField: Self = Self(4);
            pub const TidalFlat: Self = Self(5);
            pub const RiverDelta: Self = Self(6);
            pub const MangroveSwamp: Self = Self(7);
            pub const FreshwaterMarsh: Self = Self(8);
            pub const Floodplain: Self = Self(9);
            pub const AlluvialPlain: Self = Self(10);
            pub const PrairieSteppe: Self = Self(11);
            pub const MixedWoodland: Self = Self(12);
            pub const BorealTaiga: Self = Self(13);
            pub const PeatHeath: Self = Self(14);
            pub const HotDesertErg: Self = Self(15);
            pub const RockyReg: Self = Self(16);
            pub const SemiAridScrub: Self = Self(17);
            pub const SaltFlat: Self = Self(18);
            pub const OasisBasin: Self = Self(19);
            pub const Tundra: Self = Self(20);
            pub const PeriglacialSteppe: Self = Self(21);
            pub const Glacier: Self = Self(22);
            pub const SeasonalSnowfield: Self = Self(23);
            pub const RollingHills: Self = Self(24);
            pub const HighPlateau: Self = Self(25);
            pub const AlpineMountain: Self = Self(26);
            pub const KarstHighland: Self = Self(27);
            pub const CanyonBadlands: Self = Self(28);
            pub const ActiveVolcanoSlope: Self = Self(29);
            pub const BasalticLavaField: Self = Self(30);
            pub const AshPlain: Self = Self(31);
            pub const FumaroleBasin: Self = Self(32);
            pub const ImpactCraterField: Self = Self(33);
            pub const KarstCavernMouth: Self = Self(34);
            pub const SinkholeField: Self = Self(35);
            pub const AquiferCeiling: Self = Self(36);

            pub const ENUM_MIN: u16 = 0;
            pub const ENUM_MAX: u16 = 36;
            pub const ENUM_VALUES: &'static [Self] = &[
                Self::DeepOcean,
                Self::ContinentalShelf,
                Self::InlandSea,
                Self::CoralShelf,
                Self::HydrothermalVentField,
                Self::TidalFlat,
                Self::RiverDelta,
                Self::MangroveSwamp,
                Self::FreshwaterMarsh,
                Self::Floodplain,
                Self::AlluvialPlain,
                Self::PrairieSteppe,
                Self::MixedWoodland,
                Self::BorealTaiga,
                Self::PeatHeath,
                Self::HotDesertErg,
                Self::RockyReg,
                Self::SemiAridScrub,
                Self::SaltFlat,
                Self::OasisBasin,
                Self::Tundra,
                Self::PeriglacialSteppe,
                Self::Glacier,
                Self::SeasonalSnowfield,
                Self::RollingHills,
                Self::HighPlateau,
                Self::AlpineMountain,
                Self::KarstHighland,
                Self::CanyonBadlands,
                Self::ActiveVolcanoSlope,
                Self::BasalticLavaField,
                Self::AshPlain,
                Self::FumaroleBasin,
                Self::ImpactCraterField,
                Self::KarstCavernMouth,
                Self::SinkholeField,
                Self::AquiferCeiling,
            ];
            /// Returns the variant's name or "" if unknown.
            pub fn variant_name(self) -> Option<&'static str> {
                match self {
                    Self::DeepOcean => Some("DeepOcean"),
                    Self::ContinentalShelf => Some("ContinentalShelf"),
                    Self::InlandSea => Some("InlandSea"),
                    Self::CoralShelf => Some("CoralShelf"),
                    Self::HydrothermalVentField => Some("HydrothermalVentField"),
                    Self::TidalFlat => Some("TidalFlat"),
                    Self::RiverDelta => Some("RiverDelta"),
                    Self::MangroveSwamp => Some("MangroveSwamp"),
                    Self::FreshwaterMarsh => Some("FreshwaterMarsh"),
                    Self::Floodplain => Some("Floodplain"),
                    Self::AlluvialPlain => Some("AlluvialPlain"),
                    Self::PrairieSteppe => Some("PrairieSteppe"),
                    Self::MixedWoodland => Some("MixedWoodland"),
                    Self::BorealTaiga => Some("BorealTaiga"),
                    Self::PeatHeath => Some("PeatHeath"),
                    Self::HotDesertErg => Some("HotDesertErg"),
                    Self::RockyReg => Some("RockyReg"),
                    Self::SemiAridScrub => Some("SemiAridScrub"),
                    Self::SaltFlat => Some("SaltFlat"),
                    Self::OasisBasin => Some("OasisBasin"),
                    Self::Tundra => Some("Tundra"),
                    Self::PeriglacialSteppe => Some("PeriglacialSteppe"),
                    Self::Glacier => Some("Glacier"),
                    Self::SeasonalSnowfield => Some("SeasonalSnowfield"),
                    Self::RollingHills => Some("RollingHills"),
                    Self::HighPlateau => Some("HighPlateau"),
                    Self::AlpineMountain => Some("AlpineMountain"),
                    Self::KarstHighland => Some("KarstHighland"),
                    Self::CanyonBadlands => Some("CanyonBadlands"),
                    Self::ActiveVolcanoSlope => Some("ActiveVolcanoSlope"),
                    Self::BasalticLavaField => Some("BasalticLavaField"),
                    Self::AshPlain => Some("AshPlain"),
                    Self::FumaroleBasin => Some("FumaroleBasin"),
                    Self::ImpactCraterField => Some("ImpactCraterField"),
                    Self::KarstCavernMouth => Some("KarstCavernMouth"),
                    Self::SinkholeField => Some("SinkholeField"),
                    Self::AquiferCeiling => Some("AquiferCeiling"),
                    _ => None,
                }
            }
        }
        impl core::fmt::Debug for TerrainType {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                if let Some(name) = self.variant_name() {
                    f.write_str(name)
                } else {
                    f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
                }
            }
        }
        impl<'a> flatbuffers::Follow<'a> for TerrainType {
            type Inner = Self;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                let b = unsafe { flatbuffers::read_scalar_at::<u16>(buf, loc) };
                Self(b)
            }
        }

        impl flatbuffers::Push for TerrainType {
            type Output = TerrainType;
            #[inline]
            unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
                unsafe {
                    flatbuffers::emplace_scalar::<u16>(dst, self.0);
                }
            }
        }

        impl flatbuffers::EndianScalar for TerrainType {
            type Scalar = u16;
            #[inline]
            fn to_little_endian(self) -> u16 {
                self.0.to_le()
            }
            #[inline]
            #[allow(clippy::wrong_self_convention)]
            fn from_little_endian(v: u16) -> Self {
                let b = u16::from_le(v);
                Self(b)
            }
        }

        impl<'a> flatbuffers::Verifiable for TerrainType {
            #[inline]
            fn run_verifier(
                v: &mut flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                u16::run_verifier(v, pos)
            }
        }

        impl flatbuffers::SimpleToVerifyInSlice for TerrainType {}
        #[deprecated(
            since = "2.0.0",
            note = "Use associated constants instead. This will no longer be generated in 2021."
        )]
        pub const ENUM_MIN_CORRUPTION_SUBSYSTEM: u8 = 0;
        #[deprecated(
            since = "2.0.0",
            note = "Use associated constants instead. This will no longer be generated in 2021."
        )]
        pub const ENUM_MAX_CORRUPTION_SUBSYSTEM: u8 = 3;
        #[deprecated(
            since = "2.0.0",
            note = "Use associated constants instead. This will no longer be generated in 2021."
        )]
        #[allow(non_camel_case_types)]
        pub const ENUM_VALUES_CORRUPTION_SUBSYSTEM: [CorruptionSubsystem; 4] = [
            CorruptionSubsystem::Logistics,
            CorruptionSubsystem::Trade,
            CorruptionSubsystem::Military,
            CorruptionSubsystem::Governance,
        ];

        #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
        #[repr(transparent)]
        pub struct CorruptionSubsystem(pub u8);
        #[allow(non_upper_case_globals)]
        impl CorruptionSubsystem {
            pub const Logistics: Self = Self(0);
            pub const Trade: Self = Self(1);
            pub const Military: Self = Self(2);
            pub const Governance: Self = Self(3);

            pub const ENUM_MIN: u8 = 0;
            pub const ENUM_MAX: u8 = 3;
            pub const ENUM_VALUES: &'static [Self] = &[
                Self::Logistics,
                Self::Trade,
                Self::Military,
                Self::Governance,
            ];
            /// Returns the variant's name or "" if unknown.
            pub fn variant_name(self) -> Option<&'static str> {
                match self {
                    Self::Logistics => Some("Logistics"),
                    Self::Trade => Some("Trade"),
                    Self::Military => Some("Military"),
                    Self::Governance => Some("Governance"),
                    _ => None,
                }
            }
        }
        impl core::fmt::Debug for CorruptionSubsystem {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                if let Some(name) = self.variant_name() {
                    f.write_str(name)
                } else {
                    f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
                }
            }
        }
        impl<'a> flatbuffers::Follow<'a> for CorruptionSubsystem {
            type Inner = Self;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                let b = unsafe { flatbuffers::read_scalar_at::<u8>(buf, loc) };
                Self(b)
            }
        }

        impl flatbuffers::Push for CorruptionSubsystem {
            type Output = CorruptionSubsystem;
            #[inline]
            unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
                unsafe {
                    flatbuffers::emplace_scalar::<u8>(dst, self.0);
                }
            }
        }

        impl flatbuffers::EndianScalar for CorruptionSubsystem {
            type Scalar = u8;
            #[inline]
            fn to_little_endian(self) -> u8 {
                self.0.to_le()
            }
            #[inline]
            #[allow(clippy::wrong_self_convention)]
            fn from_little_endian(v: u8) -> Self {
                let b = u8::from_le(v);
                Self(b)
            }
        }

        impl<'a> flatbuffers::Verifiable for CorruptionSubsystem {
            #[inline]
            fn run_verifier(
                v: &mut flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                u8::run_verifier(v, pos)
            }
        }

        impl flatbuffers::SimpleToVerifyInSlice for CorruptionSubsystem {}
        #[deprecated(
            since = "2.0.0",
            note = "Use associated constants instead. This will no longer be generated in 2021."
        )]
        pub const ENUM_MIN_SENTIMENT_DRIVER_CATEGORY: u8 = 0;
        #[deprecated(
            since = "2.0.0",
            note = "Use associated constants instead. This will no longer be generated in 2021."
        )]
        pub const ENUM_MAX_SENTIMENT_DRIVER_CATEGORY: u8 = 2;
        #[deprecated(
            since = "2.0.0",
            note = "Use associated constants instead. This will no longer be generated in 2021."
        )]
        #[allow(non_camel_case_types)]
        pub const ENUM_VALUES_SENTIMENT_DRIVER_CATEGORY: [SentimentDriverCategory; 3] = [
            SentimentDriverCategory::Policy,
            SentimentDriverCategory::Incident,
            SentimentDriverCategory::Influencer,
        ];

        #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
        #[repr(transparent)]
        pub struct SentimentDriverCategory(pub u8);
        #[allow(non_upper_case_globals)]
        impl SentimentDriverCategory {
            pub const Policy: Self = Self(0);
            pub const Incident: Self = Self(1);
            pub const Influencer: Self = Self(2);

            pub const ENUM_MIN: u8 = 0;
            pub const ENUM_MAX: u8 = 2;
            pub const ENUM_VALUES: &'static [Self] =
                &[Self::Policy, Self::Incident, Self::Influencer];
            /// Returns the variant's name or "" if unknown.
            pub fn variant_name(self) -> Option<&'static str> {
                match self {
                    Self::Policy => Some("Policy"),
                    Self::Incident => Some("Incident"),
                    Self::Influencer => Some("Influencer"),
                    _ => None,
                }
            }
        }
        impl core::fmt::Debug for SentimentDriverCategory {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                if let Some(name) = self.variant_name() {
                    f.write_str(name)
                } else {
                    f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
                }
            }
        }
        impl<'a> flatbuffers::Follow<'a> for SentimentDriverCategory {
            type Inner = Self;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                let b = unsafe { flatbuffers::read_scalar_at::<u8>(buf, loc) };
                Self(b)
            }
        }

        impl flatbuffers::Push for SentimentDriverCategory {
            type Output = SentimentDriverCategory;
            #[inline]
            unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
                unsafe {
                    flatbuffers::emplace_scalar::<u8>(dst, self.0);
                }
            }
        }

        impl flatbuffers::EndianScalar for SentimentDriverCategory {
            type Scalar = u8;
            #[inline]
            fn to_little_endian(self) -> u8 {
                self.0.to_le()
            }
            #[inline]
            #[allow(clippy::wrong_self_convention)]
            fn from_little_endian(v: u8) -> Self {
                let b = u8::from_le(v);
                Self(b)
            }
        }

        impl<'a> flatbuffers::Verifiable for SentimentDriverCategory {
            #[inline]
            fn run_verifier(
                v: &mut flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                u8::run_verifier(v, pos)
            }
        }

        impl flatbuffers::SimpleToVerifyInSlice for SentimentDriverCategory {}
        #[deprecated(
            since = "2.0.0",
            note = "Use associated constants instead. This will no longer be generated in 2021."
        )]
        pub const ENUM_MIN_SNAPSHOT_PAYLOAD: u8 = 0;
        #[deprecated(
            since = "2.0.0",
            note = "Use associated constants instead. This will no longer be generated in 2021."
        )]
        pub const ENUM_MAX_SNAPSHOT_PAYLOAD: u8 = 2;
        #[deprecated(
            since = "2.0.0",
            note = "Use associated constants instead. This will no longer be generated in 2021."
        )]
        #[allow(non_camel_case_types)]
        pub const ENUM_VALUES_SNAPSHOT_PAYLOAD: [SnapshotPayload; 3] = [
            SnapshotPayload::NONE,
            SnapshotPayload::snapshot,
            SnapshotPayload::delta,
        ];

        #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
        #[repr(transparent)]
        pub struct SnapshotPayload(pub u8);
        #[allow(non_upper_case_globals)]
        impl SnapshotPayload {
            pub const NONE: Self = Self(0);
            pub const snapshot: Self = Self(1);
            pub const delta: Self = Self(2);

            pub const ENUM_MIN: u8 = 0;
            pub const ENUM_MAX: u8 = 2;
            pub const ENUM_VALUES: &'static [Self] = &[Self::NONE, Self::snapshot, Self::delta];
            /// Returns the variant's name or "" if unknown.
            pub fn variant_name(self) -> Option<&'static str> {
                match self {
                    Self::NONE => Some("NONE"),
                    Self::snapshot => Some("snapshot"),
                    Self::delta => Some("delta"),
                    _ => None,
                }
            }
        }
        impl core::fmt::Debug for SnapshotPayload {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                if let Some(name) = self.variant_name() {
                    f.write_str(name)
                } else {
                    f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
                }
            }
        }
        impl<'a> flatbuffers::Follow<'a> for SnapshotPayload {
            type Inner = Self;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                let b = unsafe { flatbuffers::read_scalar_at::<u8>(buf, loc) };
                Self(b)
            }
        }

        impl flatbuffers::Push for SnapshotPayload {
            type Output = SnapshotPayload;
            #[inline]
            unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
                unsafe {
                    flatbuffers::emplace_scalar::<u8>(dst, self.0);
                }
            }
        }

        impl flatbuffers::EndianScalar for SnapshotPayload {
            type Scalar = u8;
            #[inline]
            fn to_little_endian(self) -> u8 {
                self.0.to_le()
            }
            #[inline]
            #[allow(clippy::wrong_self_convention)]
            fn from_little_endian(v: u8) -> Self {
                let b = u8::from_le(v);
                Self(b)
            }
        }

        impl<'a> flatbuffers::Verifiable for SnapshotPayload {
            #[inline]
            fn run_verifier(
                v: &mut flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                u8::run_verifier(v, pos)
            }
        }

        impl flatbuffers::SimpleToVerifyInSlice for SnapshotPayload {}
        pub struct SnapshotPayloadUnionTableOffset {}

        pub enum TerrainSampleOffset {}
        #[derive(Copy, Clone, PartialEq)]

        pub struct TerrainSample<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for TerrainSample<'a> {
            type Inner = TerrainSample<'a>;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: unsafe { flatbuffers::Table::new(buf, loc) },
                }
            }
        }

        impl<'a> TerrainSample<'a> {
            pub const VT_TERRAIN: flatbuffers::VOffsetT = 4;
            pub const VT_TAGS: flatbuffers::VOffsetT = 6;

            #[inline]
            pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                TerrainSample { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<
                'bldr: 'args,
                'args: 'mut_bldr,
                'mut_bldr,
                A: flatbuffers::Allocator + 'bldr,
            >(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
                args: &'args TerrainSampleArgs,
            ) -> flatbuffers::WIPOffset<TerrainSample<'bldr>> {
                let mut builder = TerrainSampleBuilder::new(_fbb);
                builder.add_tags(args.tags);
                builder.add_terrain(args.terrain);
                builder.finish()
            }

            #[inline]
            pub fn terrain(&self) -> TerrainType {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<TerrainType>(TerrainSample::VT_TERRAIN, Some(TerrainType::DeepOcean))
                        .unwrap()
                }
            }
            #[inline]
            pub fn tags(&self) -> u16 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<u16>(TerrainSample::VT_TAGS, Some(0))
                        .unwrap()
                }
            }
        }

        impl flatbuffers::Verifiable for TerrainSample<'_> {
            #[inline]
            fn run_verifier(
                v: &mut flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                v.visit_table(pos)?
                    .visit_field::<TerrainType>("terrain", Self::VT_TERRAIN, false)?
                    .visit_field::<u16>("tags", Self::VT_TAGS, false)?
                    .finish();
                Ok(())
            }
        }
        pub struct TerrainSampleArgs {
            pub terrain: TerrainType,
            pub tags: u16,
        }
        impl<'a> Default for TerrainSampleArgs {
            #[inline]
            fn default() -> Self {
                TerrainSampleArgs {
                    terrain: TerrainType::DeepOcean,
                    tags: 0,
                }
            }
        }

        pub struct TerrainSampleBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> TerrainSampleBuilder<'a, 'b, A> {
            #[inline]
            pub fn add_terrain(&mut self, terrain: TerrainType) {
                self.fbb_.push_slot::<TerrainType>(
                    TerrainSample::VT_TERRAIN,
                    terrain,
                    TerrainType::DeepOcean,
                );
            }
            #[inline]
            pub fn add_tags(&mut self, tags: u16) {
                self.fbb_.push_slot::<u16>(TerrainSample::VT_TAGS, tags, 0);
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
            ) -> TerrainSampleBuilder<'a, 'b, A> {
                let start = _fbb.start_table();
                TerrainSampleBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<TerrainSample<'a>> {
                let o = self.fbb_.end_table(self.start_);
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        impl core::fmt::Debug for TerrainSample<'_> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                let mut ds = f.debug_struct("TerrainSample");
                ds.field("terrain", &self.terrain());
                ds.field("tags", &self.tags());
                ds.finish()
            }
        }
        pub enum TerrainOverlayOffset {}
        #[derive(Copy, Clone, PartialEq)]

        pub struct TerrainOverlay<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for TerrainOverlay<'a> {
            type Inner = TerrainOverlay<'a>;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: unsafe { flatbuffers::Table::new(buf, loc) },
                }
            }
        }

        impl<'a> TerrainOverlay<'a> {
            pub const VT_WIDTH: flatbuffers::VOffsetT = 4;
            pub const VT_HEIGHT: flatbuffers::VOffsetT = 6;
            pub const VT_SAMPLES: flatbuffers::VOffsetT = 8;

            #[inline]
            pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                TerrainOverlay { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<
                'bldr: 'args,
                'args: 'mut_bldr,
                'mut_bldr,
                A: flatbuffers::Allocator + 'bldr,
            >(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
                args: &'args TerrainOverlayArgs<'args>,
            ) -> flatbuffers::WIPOffset<TerrainOverlay<'bldr>> {
                let mut builder = TerrainOverlayBuilder::new(_fbb);
                if let Some(x) = args.samples {
                    builder.add_samples(x);
                }
                builder.add_height(args.height);
                builder.add_width(args.width);
                builder.finish()
            }

            #[inline]
            pub fn width(&self) -> u32 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<u32>(TerrainOverlay::VT_WIDTH, Some(0))
                        .unwrap()
                }
            }
            #[inline]
            pub fn height(&self) -> u32 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<u32>(TerrainOverlay::VT_HEIGHT, Some(0))
                        .unwrap()
                }
            }
            #[inline]
            pub fn samples(
                &self,
            ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<TerrainSample<'a>>>>
            {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab.get::<flatbuffers::ForwardsUOffset<
                        flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<TerrainSample>>,
                    >>(TerrainOverlay::VT_SAMPLES, None)
                }
            }
        }

        impl flatbuffers::Verifiable for TerrainOverlay<'_> {
            #[inline]
            fn run_verifier(
                v: &mut flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                v.visit_table(pos)?
                    .visit_field::<u32>("width", Self::VT_WIDTH, false)?
                    .visit_field::<u32>("height", Self::VT_HEIGHT, false)?
                    .visit_field::<flatbuffers::ForwardsUOffset<
                        flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<TerrainSample>>,
                    >>("samples", Self::VT_SAMPLES, false)?
                    .finish();
                Ok(())
            }
        }
        pub struct TerrainOverlayArgs<'a> {
            pub width: u32,
            pub height: u32,
            pub samples: Option<
                flatbuffers::WIPOffset<
                    flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<TerrainSample<'a>>>,
                >,
            >,
        }
        impl<'a> Default for TerrainOverlayArgs<'a> {
            #[inline]
            fn default() -> Self {
                TerrainOverlayArgs {
                    width: 0,
                    height: 0,
                    samples: None,
                }
            }
        }

        pub struct TerrainOverlayBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> TerrainOverlayBuilder<'a, 'b, A> {
            #[inline]
            pub fn add_width(&mut self, width: u32) {
                self.fbb_
                    .push_slot::<u32>(TerrainOverlay::VT_WIDTH, width, 0);
            }
            #[inline]
            pub fn add_height(&mut self, height: u32) {
                self.fbb_
                    .push_slot::<u32>(TerrainOverlay::VT_HEIGHT, height, 0);
            }
            #[inline]
            pub fn add_samples(
                &mut self,
                samples: flatbuffers::WIPOffset<
                    flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<TerrainSample<'b>>>,
                >,
            ) {
                self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                    TerrainOverlay::VT_SAMPLES,
                    samples,
                );
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
            ) -> TerrainOverlayBuilder<'a, 'b, A> {
                let start = _fbb.start_table();
                TerrainOverlayBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<TerrainOverlay<'a>> {
                let o = self.fbb_.end_table(self.start_);
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        impl core::fmt::Debug for TerrainOverlay<'_> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                let mut ds = f.debug_struct("TerrainOverlay");
                ds.field("width", &self.width());
                ds.field("height", &self.height());
                ds.field("samples", &self.samples());
                ds.finish()
            }
        }
        pub enum InfluentialIndividualStateOffset {}
        #[derive(Copy, Clone, PartialEq)]

        pub struct InfluentialIndividualState<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for InfluentialIndividualState<'a> {
            type Inner = InfluentialIndividualState<'a>;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: unsafe { flatbuffers::Table::new(buf, loc) },
                }
            }
        }

        impl<'a> InfluentialIndividualState<'a> {
            pub const VT_ID: flatbuffers::VOffsetT = 4;
            pub const VT_NAME: flatbuffers::VOffsetT = 6;
            pub const VT_INFLUENCE: flatbuffers::VOffsetT = 8;
            pub const VT_GROWTHRATE: flatbuffers::VOffsetT = 10;
            pub const VT_BASELINEGROWTH: flatbuffers::VOffsetT = 12;
            pub const VT_NOTORIETY: flatbuffers::VOffsetT = 14;
            pub const VT_SENTIMENTKNOWLEDGE: flatbuffers::VOffsetT = 16;
            pub const VT_SENTIMENTTRUST: flatbuffers::VOffsetT = 18;
            pub const VT_SENTIMENTEQUITY: flatbuffers::VOffsetT = 20;
            pub const VT_SENTIMENTAGENCY: flatbuffers::VOffsetT = 22;
            pub const VT_SENTIMENTWEIGHTKNOWLEDGE: flatbuffers::VOffsetT = 24;
            pub const VT_SENTIMENTWEIGHTTRUST: flatbuffers::VOffsetT = 26;
            pub const VT_SENTIMENTWEIGHTEQUITY: flatbuffers::VOffsetT = 28;
            pub const VT_SENTIMENTWEIGHTAGENCY: flatbuffers::VOffsetT = 30;
            pub const VT_LOGISTICSBONUS: flatbuffers::VOffsetT = 32;
            pub const VT_MORALEBONUS: flatbuffers::VOffsetT = 34;
            pub const VT_POWERBONUS: flatbuffers::VOffsetT = 36;
            pub const VT_LOGISTICSWEIGHT: flatbuffers::VOffsetT = 38;
            pub const VT_MORALEWEIGHT: flatbuffers::VOffsetT = 40;
            pub const VT_POWERWEIGHT: flatbuffers::VOffsetT = 42;
            pub const VT_SUPPORTCHARGE: flatbuffers::VOffsetT = 44;
            pub const VT_SUPPRESSPRESSURE: flatbuffers::VOffsetT = 46;
            pub const VT_DOMAINS: flatbuffers::VOffsetT = 48;
            pub const VT_SCOPE: flatbuffers::VOffsetT = 50;
            pub const VT_GENERATIONSCOPE: flatbuffers::VOffsetT = 52;
            pub const VT_SUPPORTED: flatbuffers::VOffsetT = 54;
            pub const VT_SUPPRESSED: flatbuffers::VOffsetT = 56;
            pub const VT_LIFECYCLE: flatbuffers::VOffsetT = 58;
            pub const VT_COHERENCE: flatbuffers::VOffsetT = 60;
            pub const VT_TICKSINSTATUS: flatbuffers::VOffsetT = 62;
            pub const VT_AUDIENCEGENERATIONS: flatbuffers::VOffsetT = 64;
            pub const VT_SUPPORTPOPULAR: flatbuffers::VOffsetT = 66;
            pub const VT_SUPPORTPEER: flatbuffers::VOffsetT = 68;
            pub const VT_SUPPORTINSTITUTIONAL: flatbuffers::VOffsetT = 70;
            pub const VT_SUPPORTHUMANITARIAN: flatbuffers::VOffsetT = 72;
            pub const VT_WEIGHTPOPULAR: flatbuffers::VOffsetT = 74;
            pub const VT_WEIGHTPEER: flatbuffers::VOffsetT = 76;
            pub const VT_WEIGHTINSTITUTIONAL: flatbuffers::VOffsetT = 78;
            pub const VT_WEIGHTHUMANITARIAN: flatbuffers::VOffsetT = 80;
            pub const VT_CULTURERESONANCE: flatbuffers::VOffsetT = 82;

            #[inline]
            pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                InfluentialIndividualState { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<
                'bldr: 'args,
                'args: 'mut_bldr,
                'mut_bldr,
                A: flatbuffers::Allocator + 'bldr,
            >(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
                args: &'args InfluentialIndividualStateArgs<'args>,
            ) -> flatbuffers::WIPOffset<InfluentialIndividualState<'bldr>> {
                let mut builder = InfluentialIndividualStateBuilder::new(_fbb);
                builder.add_weightHumanitarian(args.weightHumanitarian);
                builder.add_weightInstitutional(args.weightInstitutional);
                builder.add_weightPeer(args.weightPeer);
                builder.add_weightPopular(args.weightPopular);
                builder.add_supportHumanitarian(args.supportHumanitarian);
                builder.add_supportInstitutional(args.supportInstitutional);
                builder.add_supportPeer(args.supportPeer);
                builder.add_supportPopular(args.supportPopular);
                builder.add_coherence(args.coherence);
                builder.add_suppressPressure(args.suppressPressure);
                builder.add_supportCharge(args.supportCharge);
                builder.add_powerWeight(args.powerWeight);
                builder.add_moraleWeight(args.moraleWeight);
                builder.add_logisticsWeight(args.logisticsWeight);
                builder.add_powerBonus(args.powerBonus);
                builder.add_moraleBonus(args.moraleBonus);
                builder.add_logisticsBonus(args.logisticsBonus);
                builder.add_sentimentWeightAgency(args.sentimentWeightAgency);
                builder.add_sentimentWeightEquity(args.sentimentWeightEquity);
                builder.add_sentimentWeightTrust(args.sentimentWeightTrust);
                builder.add_sentimentWeightKnowledge(args.sentimentWeightKnowledge);
                builder.add_sentimentAgency(args.sentimentAgency);
                builder.add_sentimentEquity(args.sentimentEquity);
                builder.add_sentimentTrust(args.sentimentTrust);
                builder.add_sentimentKnowledge(args.sentimentKnowledge);
                builder.add_notoriety(args.notoriety);
                builder.add_baselineGrowth(args.baselineGrowth);
                builder.add_growthRate(args.growthRate);
                builder.add_influence(args.influence);
                if let Some(x) = args.cultureResonance {
                    builder.add_cultureResonance(x);
                }
                if let Some(x) = args.audienceGenerations {
                    builder.add_audienceGenerations(x);
                }
                builder.add_domains(args.domains);
                if let Some(x) = args.name {
                    builder.add_name(x);
                }
                builder.add_id(args.id);
                builder.add_ticksInStatus(args.ticksInStatus);
                builder.add_generationScope(args.generationScope);
                builder.add_lifecycle(args.lifecycle);
                builder.add_suppressed(args.suppressed);
                builder.add_supported(args.supported);
                builder.add_scope(args.scope);
                builder.finish()
            }

            #[inline]
            pub fn id(&self) -> u32 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<u32>(InfluentialIndividualState::VT_ID, Some(0))
                        .unwrap()
                }
            }
            #[inline]
            pub fn name(&self) -> Option<&'a str> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                        InfluentialIndividualState::VT_NAME,
                        None,
                    )
                }
            }
            #[inline]
            pub fn influence(&self) -> i64 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<i64>(InfluentialIndividualState::VT_INFLUENCE, Some(0))
                        .unwrap()
                }
            }
            #[inline]
            pub fn growthRate(&self) -> i64 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<i64>(InfluentialIndividualState::VT_GROWTHRATE, Some(0))
                        .unwrap()
                }
            }
            #[inline]
            pub fn baselineGrowth(&self) -> i64 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<i64>(InfluentialIndividualState::VT_BASELINEGROWTH, Some(0))
                        .unwrap()
                }
            }
            #[inline]
            pub fn notoriety(&self) -> i64 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<i64>(InfluentialIndividualState::VT_NOTORIETY, Some(0))
                        .unwrap()
                }
            }
            #[inline]
            pub fn sentimentKnowledge(&self) -> i64 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<i64>(InfluentialIndividualState::VT_SENTIMENTKNOWLEDGE, Some(0))
                        .unwrap()
                }
            }
            #[inline]
            pub fn sentimentTrust(&self) -> i64 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<i64>(InfluentialIndividualState::VT_SENTIMENTTRUST, Some(0))
                        .unwrap()
                }
            }
            #[inline]
            pub fn sentimentEquity(&self) -> i64 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<i64>(InfluentialIndividualState::VT_SENTIMENTEQUITY, Some(0))
                        .unwrap()
                }
            }
            #[inline]
            pub fn sentimentAgency(&self) -> i64 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<i64>(InfluentialIndividualState::VT_SENTIMENTAGENCY, Some(0))
                        .unwrap()
                }
            }
            #[inline]
            pub fn sentimentWeightKnowledge(&self) -> i64 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<i64>(
                            InfluentialIndividualState::VT_SENTIMENTWEIGHTKNOWLEDGE,
                            Some(0),
                        )
                        .unwrap()
                }
            }
            #[inline]
            pub fn sentimentWeightTrust(&self) -> i64 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<i64>(InfluentialIndividualState::VT_SENTIMENTWEIGHTTRUST, Some(0))
                        .unwrap()
                }
            }
            #[inline]
            pub fn sentimentWeightEquity(&self) -> i64 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<i64>(
                            InfluentialIndividualState::VT_SENTIMENTWEIGHTEQUITY,
                            Some(0),
                        )
                        .unwrap()
                }
            }
            #[inline]
            pub fn sentimentWeightAgency(&self) -> i64 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<i64>(
                            InfluentialIndividualState::VT_SENTIMENTWEIGHTAGENCY,
                            Some(0),
                        )
                        .unwrap()
                }
            }
            #[inline]
            pub fn logisticsBonus(&self) -> i64 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<i64>(InfluentialIndividualState::VT_LOGISTICSBONUS, Some(0))
                        .unwrap()
                }
            }
            #[inline]
            pub fn moraleBonus(&self) -> i64 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<i64>(InfluentialIndividualState::VT_MORALEBONUS, Some(0))
                        .unwrap()
                }
            }
            #[inline]
            pub fn powerBonus(&self) -> i64 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<i64>(InfluentialIndividualState::VT_POWERBONUS, Some(0))
                        .unwrap()
                }
            }
            #[inline]
            pub fn logisticsWeight(&self) -> i64 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<i64>(InfluentialIndividualState::VT_LOGISTICSWEIGHT, Some(0))
                        .unwrap()
                }
            }
            #[inline]
            pub fn moraleWeight(&self) -> i64 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<i64>(InfluentialIndividualState::VT_MORALEWEIGHT, Some(0))
                        .unwrap()
                }
            }
            #[inline]
            pub fn powerWeight(&self) -> i64 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<i64>(InfluentialIndividualState::VT_POWERWEIGHT, Some(0))
                        .unwrap()
                }
            }
            #[inline]
            pub fn supportCharge(&self) -> i64 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<i64>(InfluentialIndividualState::VT_SUPPORTCHARGE, Some(0))
                        .unwrap()
                }
            }
            #[inline]
            pub fn suppressPressure(&self) -> i64 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<i64>(InfluentialIndividualState::VT_SUPPRESSPRESSURE, Some(0))
                        .unwrap()
                }
            }
            #[inline]
            pub fn domains(&self) -> u32 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<u32>(InfluentialIndividualState::VT_DOMAINS, Some(0))
                        .unwrap()
                }
            }
            #[inline]
            pub fn scope(&self) -> InfluenceScopeKind {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<InfluenceScopeKind>(
                            InfluentialIndividualState::VT_SCOPE,
                            Some(InfluenceScopeKind::Local),
                        )
                        .unwrap()
                }
            }
            #[inline]
            pub fn generationScope(&self) -> u16 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<u16>(InfluentialIndividualState::VT_GENERATIONSCOPE, Some(0))
                        .unwrap()
                }
            }
            #[inline]
            pub fn supported(&self) -> bool {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<bool>(InfluentialIndividualState::VT_SUPPORTED, Some(false))
                        .unwrap()
                }
            }
            #[inline]
            pub fn suppressed(&self) -> bool {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<bool>(InfluentialIndividualState::VT_SUPPRESSED, Some(false))
                        .unwrap()
                }
            }
            #[inline]
            pub fn lifecycle(&self) -> InfluenceLifecycle {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<InfluenceLifecycle>(
                            InfluentialIndividualState::VT_LIFECYCLE,
                            Some(InfluenceLifecycle::Potential),
                        )
                        .unwrap()
                }
            }
            #[inline]
            pub fn coherence(&self) -> i64 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<i64>(InfluentialIndividualState::VT_COHERENCE, Some(0))
                        .unwrap()
                }
            }
            #[inline]
            pub fn ticksInStatus(&self) -> u16 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<u16>(InfluentialIndividualState::VT_TICKSINSTATUS, Some(0))
                        .unwrap()
                }
            }
            #[inline]
            pub fn audienceGenerations(&self) -> Option<flatbuffers::Vector<'a, u16>> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u16>>>(
                            InfluentialIndividualState::VT_AUDIENCEGENERATIONS,
                            None,
                        )
                }
            }
            #[inline]
            pub fn supportPopular(&self) -> i64 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<i64>(InfluentialIndividualState::VT_SUPPORTPOPULAR, Some(0))
                        .unwrap()
                }
            }
            #[inline]
            pub fn supportPeer(&self) -> i64 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<i64>(InfluentialIndividualState::VT_SUPPORTPEER, Some(0))
                        .unwrap()
                }
            }
            #[inline]
            pub fn supportInstitutional(&self) -> i64 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<i64>(InfluentialIndividualState::VT_SUPPORTINSTITUTIONAL, Some(0))
                        .unwrap()
                }
            }
            #[inline]
            pub fn supportHumanitarian(&self) -> i64 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<i64>(InfluentialIndividualState::VT_SUPPORTHUMANITARIAN, Some(0))
                        .unwrap()
                }
            }
            #[inline]
            pub fn weightPopular(&self) -> i64 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<i64>(InfluentialIndividualState::VT_WEIGHTPOPULAR, Some(0))
                        .unwrap()
                }
            }
            #[inline]
            pub fn weightPeer(&self) -> i64 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<i64>(InfluentialIndividualState::VT_WEIGHTPEER, Some(0))
                        .unwrap()
                }
            }
            #[inline]
            pub fn weightInstitutional(&self) -> i64 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<i64>(InfluentialIndividualState::VT_WEIGHTINSTITUTIONAL, Some(0))
                        .unwrap()
                }
            }
            #[inline]
            pub fn weightHumanitarian(&self) -> i64 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<i64>(InfluentialIndividualState::VT_WEIGHTHUMANITARIAN, Some(0))
                        .unwrap()
                }
            }
            #[inline]
            pub fn cultureResonance(
                &self,
            ) -> Option<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<InfluencerCultureResonanceEntry<'a>>,
                >,
            > {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab.get::<flatbuffers::ForwardsUOffset<
                        flatbuffers::Vector<
                            'a,
                            flatbuffers::ForwardsUOffset<InfluencerCultureResonanceEntry>,
                        >,
                    >>(
                        InfluentialIndividualState::VT_CULTURERESONANCE, None
                    )
                }
            }
        }

        impl flatbuffers::Verifiable for InfluentialIndividualState<'_> {
            #[inline]
            fn run_verifier(
                v: &mut flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                v.visit_table(pos)?
                    .visit_field::<u32>("id", Self::VT_ID, false)?
                    .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                        "name",
                        Self::VT_NAME,
                        false,
                    )?
                    .visit_field::<i64>("influence", Self::VT_INFLUENCE, false)?
                    .visit_field::<i64>("growthRate", Self::VT_GROWTHRATE, false)?
                    .visit_field::<i64>("baselineGrowth", Self::VT_BASELINEGROWTH, false)?
                    .visit_field::<i64>("notoriety", Self::VT_NOTORIETY, false)?
                    .visit_field::<i64>("sentimentKnowledge", Self::VT_SENTIMENTKNOWLEDGE, false)?
                    .visit_field::<i64>("sentimentTrust", Self::VT_SENTIMENTTRUST, false)?
                    .visit_field::<i64>("sentimentEquity", Self::VT_SENTIMENTEQUITY, false)?
                    .visit_field::<i64>("sentimentAgency", Self::VT_SENTIMENTAGENCY, false)?
                    .visit_field::<i64>(
                        "sentimentWeightKnowledge",
                        Self::VT_SENTIMENTWEIGHTKNOWLEDGE,
                        false,
                    )?
                    .visit_field::<i64>(
                        "sentimentWeightTrust",
                        Self::VT_SENTIMENTWEIGHTTRUST,
                        false,
                    )?
                    .visit_field::<i64>(
                        "sentimentWeightEquity",
                        Self::VT_SENTIMENTWEIGHTEQUITY,
                        false,
                    )?
                    .visit_field::<i64>(
                        "sentimentWeightAgency",
                        Self::VT_SENTIMENTWEIGHTAGENCY,
                        false,
                    )?
                    .visit_field::<i64>("logisticsBonus", Self::VT_LOGISTICSBONUS, false)?
                    .visit_field::<i64>("moraleBonus", Self::VT_MORALEBONUS, false)?
                    .visit_field::<i64>("powerBonus", Self::VT_POWERBONUS, false)?
                    .visit_field::<i64>("logisticsWeight", Self::VT_LOGISTICSWEIGHT, false)?
                    .visit_field::<i64>("moraleWeight", Self::VT_MORALEWEIGHT, false)?
                    .visit_field::<i64>("powerWeight", Self::VT_POWERWEIGHT, false)?
                    .visit_field::<i64>("supportCharge", Self::VT_SUPPORTCHARGE, false)?
                    .visit_field::<i64>("suppressPressure", Self::VT_SUPPRESSPRESSURE, false)?
                    .visit_field::<u32>("domains", Self::VT_DOMAINS, false)?
                    .visit_field::<InfluenceScopeKind>("scope", Self::VT_SCOPE, false)?
                    .visit_field::<u16>("generationScope", Self::VT_GENERATIONSCOPE, false)?
                    .visit_field::<bool>("supported", Self::VT_SUPPORTED, false)?
                    .visit_field::<bool>("suppressed", Self::VT_SUPPRESSED, false)?
                    .visit_field::<InfluenceLifecycle>("lifecycle", Self::VT_LIFECYCLE, false)?
                    .visit_field::<i64>("coherence", Self::VT_COHERENCE, false)?
                    .visit_field::<u16>("ticksInStatus", Self::VT_TICKSINSTATUS, false)?
                    .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u16>>>(
                        "audienceGenerations",
                        Self::VT_AUDIENCEGENERATIONS,
                        false,
                    )?
                    .visit_field::<i64>("supportPopular", Self::VT_SUPPORTPOPULAR, false)?
                    .visit_field::<i64>("supportPeer", Self::VT_SUPPORTPEER, false)?
                    .visit_field::<i64>(
                        "supportInstitutional",
                        Self::VT_SUPPORTINSTITUTIONAL,
                        false,
                    )?
                    .visit_field::<i64>("supportHumanitarian", Self::VT_SUPPORTHUMANITARIAN, false)?
                    .visit_field::<i64>("weightPopular", Self::VT_WEIGHTPOPULAR, false)?
                    .visit_field::<i64>("weightPeer", Self::VT_WEIGHTPEER, false)?
                    .visit_field::<i64>("weightInstitutional", Self::VT_WEIGHTINSTITUTIONAL, false)?
                    .visit_field::<i64>("weightHumanitarian", Self::VT_WEIGHTHUMANITARIAN, false)?
                    .visit_field::<flatbuffers::ForwardsUOffset<
                        flatbuffers::Vector<
                            '_,
                            flatbuffers::ForwardsUOffset<InfluencerCultureResonanceEntry>,
                        >,
                    >>("cultureResonance", Self::VT_CULTURERESONANCE, false)?
                    .finish();
                Ok(())
            }
        }
        pub struct InfluentialIndividualStateArgs<'a> {
            pub id: u32,
            pub name: Option<flatbuffers::WIPOffset<&'a str>>,
            pub influence: i64,
            pub growthRate: i64,
            pub baselineGrowth: i64,
            pub notoriety: i64,
            pub sentimentKnowledge: i64,
            pub sentimentTrust: i64,
            pub sentimentEquity: i64,
            pub sentimentAgency: i64,
            pub sentimentWeightKnowledge: i64,
            pub sentimentWeightTrust: i64,
            pub sentimentWeightEquity: i64,
            pub sentimentWeightAgency: i64,
            pub logisticsBonus: i64,
            pub moraleBonus: i64,
            pub powerBonus: i64,
            pub logisticsWeight: i64,
            pub moraleWeight: i64,
            pub powerWeight: i64,
            pub supportCharge: i64,
            pub suppressPressure: i64,
            pub domains: u32,
            pub scope: InfluenceScopeKind,
            pub generationScope: u16,
            pub supported: bool,
            pub suppressed: bool,
            pub lifecycle: InfluenceLifecycle,
            pub coherence: i64,
            pub ticksInStatus: u16,
            pub audienceGenerations: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u16>>>,
            pub supportPopular: i64,
            pub supportPeer: i64,
            pub supportInstitutional: i64,
            pub supportHumanitarian: i64,
            pub weightPopular: i64,
            pub weightPeer: i64,
            pub weightInstitutional: i64,
            pub weightHumanitarian: i64,
            pub cultureResonance: Option<
                flatbuffers::WIPOffset<
                    flatbuffers::Vector<
                        'a,
                        flatbuffers::ForwardsUOffset<InfluencerCultureResonanceEntry<'a>>,
                    >,
                >,
            >,
        }
        impl<'a> Default for InfluentialIndividualStateArgs<'a> {
            #[inline]
            fn default() -> Self {
                InfluentialIndividualStateArgs {
                    id: 0,
                    name: None,
                    influence: 0,
                    growthRate: 0,
                    baselineGrowth: 0,
                    notoriety: 0,
                    sentimentKnowledge: 0,
                    sentimentTrust: 0,
                    sentimentEquity: 0,
                    sentimentAgency: 0,
                    sentimentWeightKnowledge: 0,
                    sentimentWeightTrust: 0,
                    sentimentWeightEquity: 0,
                    sentimentWeightAgency: 0,
                    logisticsBonus: 0,
                    moraleBonus: 0,
                    powerBonus: 0,
                    logisticsWeight: 0,
                    moraleWeight: 0,
                    powerWeight: 0,
                    supportCharge: 0,
                    suppressPressure: 0,
                    domains: 0,
                    scope: InfluenceScopeKind::Local,
                    generationScope: 0,
                    supported: false,
                    suppressed: false,
                    lifecycle: InfluenceLifecycle::Potential,
                    coherence: 0,
                    ticksInStatus: 0,
                    audienceGenerations: None,
                    supportPopular: 0,
                    supportPeer: 0,
                    supportInstitutional: 0,
                    supportHumanitarian: 0,
                    weightPopular: 0,
                    weightPeer: 0,
                    weightInstitutional: 0,
                    weightHumanitarian: 0,
                    cultureResonance: None,
                }
            }
        }

        pub struct InfluentialIndividualStateBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> InfluentialIndividualStateBuilder<'a, 'b, A> {
            #[inline]
            pub fn add_id(&mut self, id: u32) {
                self.fbb_
                    .push_slot::<u32>(InfluentialIndividualState::VT_ID, id, 0);
            }
            #[inline]
            pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b str>) {
                self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                    InfluentialIndividualState::VT_NAME,
                    name,
                );
            }
            #[inline]
            pub fn add_influence(&mut self, influence: i64) {
                self.fbb_
                    .push_slot::<i64>(InfluentialIndividualState::VT_INFLUENCE, influence, 0);
            }
            #[inline]
            pub fn add_growthRate(&mut self, growthRate: i64) {
                self.fbb_.push_slot::<i64>(
                    InfluentialIndividualState::VT_GROWTHRATE,
                    growthRate,
                    0,
                );
            }
            #[inline]
            pub fn add_baselineGrowth(&mut self, baselineGrowth: i64) {
                self.fbb_.push_slot::<i64>(
                    InfluentialIndividualState::VT_BASELINEGROWTH,
                    baselineGrowth,
                    0,
                );
            }
            #[inline]
            pub fn add_notoriety(&mut self, notoriety: i64) {
                self.fbb_
                    .push_slot::<i64>(InfluentialIndividualState::VT_NOTORIETY, notoriety, 0);
            }
            #[inline]
            pub fn add_sentimentKnowledge(&mut self, sentimentKnowledge: i64) {
                self.fbb_.push_slot::<i64>(
                    InfluentialIndividualState::VT_SENTIMENTKNOWLEDGE,
                    sentimentKnowledge,
                    0,
                );
            }
            #[inline]
            pub fn add_sentimentTrust(&mut self, sentimentTrust: i64) {
                self.fbb_.push_slot::<i64>(
                    InfluentialIndividualState::VT_SENTIMENTTRUST,
                    sentimentTrust,
                    0,
                );
            }
            #[inline]
            pub fn add_sentimentEquity(&mut self, sentimentEquity: i64) {
                self.fbb_.push_slot::<i64>(
                    InfluentialIndividualState::VT_SENTIMENTEQUITY,
                    sentimentEquity,
                    0,
                );
            }
            #[inline]
            pub fn add_sentimentAgency(&mut self, sentimentAgency: i64) {
                self.fbb_.push_slot::<i64>(
                    InfluentialIndividualState::VT_SENTIMENTAGENCY,
                    sentimentAgency,
                    0,
                );
            }
            #[inline]
            pub fn add_sentimentWeightKnowledge(&mut self, sentimentWeightKnowledge: i64) {
                self.fbb_.push_slot::<i64>(
                    InfluentialIndividualState::VT_SENTIMENTWEIGHTKNOWLEDGE,
                    sentimentWeightKnowledge,
                    0,
                );
            }
            #[inline]
            pub fn add_sentimentWeightTrust(&mut self, sentimentWeightTrust: i64) {
                self.fbb_.push_slot::<i64>(
                    InfluentialIndividualState::VT_SENTIMENTWEIGHTTRUST,
                    sentimentWeightTrust,
                    0,
                );
            }
            #[inline]
            pub fn add_sentimentWeightEquity(&mut self, sentimentWeightEquity: i64) {
                self.fbb_.push_slot::<i64>(
                    InfluentialIndividualState::VT_SENTIMENTWEIGHTEQUITY,
                    sentimentWeightEquity,
                    0,
                );
            }
            #[inline]
            pub fn add_sentimentWeightAgency(&mut self, sentimentWeightAgency: i64) {
                self.fbb_.push_slot::<i64>(
                    InfluentialIndividualState::VT_SENTIMENTWEIGHTAGENCY,
                    sentimentWeightAgency,
                    0,
                );
            }
            #[inline]
            pub fn add_logisticsBonus(&mut self, logisticsBonus: i64) {
                self.fbb_.push_slot::<i64>(
                    InfluentialIndividualState::VT_LOGISTICSBONUS,
                    logisticsBonus,
                    0,
                );
            }
            #[inline]
            pub fn add_moraleBonus(&mut self, moraleBonus: i64) {
                self.fbb_.push_slot::<i64>(
                    InfluentialIndividualState::VT_MORALEBONUS,
                    moraleBonus,
                    0,
                );
            }
            #[inline]
            pub fn add_powerBonus(&mut self, powerBonus: i64) {
                self.fbb_.push_slot::<i64>(
                    InfluentialIndividualState::VT_POWERBONUS,
                    powerBonus,
                    0,
                );
            }
            #[inline]
            pub fn add_logisticsWeight(&mut self, logisticsWeight: i64) {
                self.fbb_.push_slot::<i64>(
                    InfluentialIndividualState::VT_LOGISTICSWEIGHT,
                    logisticsWeight,
                    0,
                );
            }
            #[inline]
            pub fn add_moraleWeight(&mut self, moraleWeight: i64) {
                self.fbb_.push_slot::<i64>(
                    InfluentialIndividualState::VT_MORALEWEIGHT,
                    moraleWeight,
                    0,
                );
            }
            #[inline]
            pub fn add_powerWeight(&mut self, powerWeight: i64) {
                self.fbb_.push_slot::<i64>(
                    InfluentialIndividualState::VT_POWERWEIGHT,
                    powerWeight,
                    0,
                );
            }
            #[inline]
            pub fn add_supportCharge(&mut self, supportCharge: i64) {
                self.fbb_.push_slot::<i64>(
                    InfluentialIndividualState::VT_SUPPORTCHARGE,
                    supportCharge,
                    0,
                );
            }
            #[inline]
            pub fn add_suppressPressure(&mut self, suppressPressure: i64) {
                self.fbb_.push_slot::<i64>(
                    InfluentialIndividualState::VT_SUPPRESSPRESSURE,
                    suppressPressure,
                    0,
                );
            }
            #[inline]
            pub fn add_domains(&mut self, domains: u32) {
                self.fbb_
                    .push_slot::<u32>(InfluentialIndividualState::VT_DOMAINS, domains, 0);
            }
            #[inline]
            pub fn add_scope(&mut self, scope: InfluenceScopeKind) {
                self.fbb_.push_slot::<InfluenceScopeKind>(
                    InfluentialIndividualState::VT_SCOPE,
                    scope,
                    InfluenceScopeKind::Local,
                );
            }
            #[inline]
            pub fn add_generationScope(&mut self, generationScope: u16) {
                self.fbb_.push_slot::<u16>(
                    InfluentialIndividualState::VT_GENERATIONSCOPE,
                    generationScope,
                    0,
                );
            }
            #[inline]
            pub fn add_supported(&mut self, supported: bool) {
                self.fbb_.push_slot::<bool>(
                    InfluentialIndividualState::VT_SUPPORTED,
                    supported,
                    false,
                );
            }
            #[inline]
            pub fn add_suppressed(&mut self, suppressed: bool) {
                self.fbb_.push_slot::<bool>(
                    InfluentialIndividualState::VT_SUPPRESSED,
                    suppressed,
                    false,
                );
            }
            #[inline]
            pub fn add_lifecycle(&mut self, lifecycle: InfluenceLifecycle) {
                self.fbb_.push_slot::<InfluenceLifecycle>(
                    InfluentialIndividualState::VT_LIFECYCLE,
                    lifecycle,
                    InfluenceLifecycle::Potential,
                );
            }
            #[inline]
            pub fn add_coherence(&mut self, coherence: i64) {
                self.fbb_
                    .push_slot::<i64>(InfluentialIndividualState::VT_COHERENCE, coherence, 0);
            }
            #[inline]
            pub fn add_ticksInStatus(&mut self, ticksInStatus: u16) {
                self.fbb_.push_slot::<u16>(
                    InfluentialIndividualState::VT_TICKSINSTATUS,
                    ticksInStatus,
                    0,
                );
            }
            #[inline]
            pub fn add_audienceGenerations(
                &mut self,
                audienceGenerations: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u16>>,
            ) {
                self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                    InfluentialIndividualState::VT_AUDIENCEGENERATIONS,
                    audienceGenerations,
                );
            }
            #[inline]
            pub fn add_supportPopular(&mut self, supportPopular: i64) {
                self.fbb_.push_slot::<i64>(
                    InfluentialIndividualState::VT_SUPPORTPOPULAR,
                    supportPopular,
                    0,
                );
            }
            #[inline]
            pub fn add_supportPeer(&mut self, supportPeer: i64) {
                self.fbb_.push_slot::<i64>(
                    InfluentialIndividualState::VT_SUPPORTPEER,
                    supportPeer,
                    0,
                );
            }
            #[inline]
            pub fn add_supportInstitutional(&mut self, supportInstitutional: i64) {
                self.fbb_.push_slot::<i64>(
                    InfluentialIndividualState::VT_SUPPORTINSTITUTIONAL,
                    supportInstitutional,
                    0,
                );
            }
            #[inline]
            pub fn add_supportHumanitarian(&mut self, supportHumanitarian: i64) {
                self.fbb_.push_slot::<i64>(
                    InfluentialIndividualState::VT_SUPPORTHUMANITARIAN,
                    supportHumanitarian,
                    0,
                );
            }
            #[inline]
            pub fn add_weightPopular(&mut self, weightPopular: i64) {
                self.fbb_.push_slot::<i64>(
                    InfluentialIndividualState::VT_WEIGHTPOPULAR,
                    weightPopular,
                    0,
                );
            }
            #[inline]
            pub fn add_weightPeer(&mut self, weightPeer: i64) {
                self.fbb_.push_slot::<i64>(
                    InfluentialIndividualState::VT_WEIGHTPEER,
                    weightPeer,
                    0,
                );
            }
            #[inline]
            pub fn add_weightInstitutional(&mut self, weightInstitutional: i64) {
                self.fbb_.push_slot::<i64>(
                    InfluentialIndividualState::VT_WEIGHTINSTITUTIONAL,
                    weightInstitutional,
                    0,
                );
            }
            #[inline]
            pub fn add_weightHumanitarian(&mut self, weightHumanitarian: i64) {
                self.fbb_.push_slot::<i64>(
                    InfluentialIndividualState::VT_WEIGHTHUMANITARIAN,
                    weightHumanitarian,
                    0,
                );
            }
            #[inline]
            pub fn add_cultureResonance(
                &mut self,
                cultureResonance: flatbuffers::WIPOffset<
                    flatbuffers::Vector<
                        'b,
                        flatbuffers::ForwardsUOffset<InfluencerCultureResonanceEntry<'b>>,
                    >,
                >,
            ) {
                self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                    InfluentialIndividualState::VT_CULTURERESONANCE,
                    cultureResonance,
                );
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
            ) -> InfluentialIndividualStateBuilder<'a, 'b, A> {
                let start = _fbb.start_table();
                InfluentialIndividualStateBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<InfluentialIndividualState<'a>> {
                let o = self.fbb_.end_table(self.start_);
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        impl core::fmt::Debug for InfluentialIndividualState<'_> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                let mut ds = f.debug_struct("InfluentialIndividualState");
                ds.field("id", &self.id());
                ds.field("name", &self.name());
                ds.field("influence", &self.influence());
                ds.field("growthRate", &self.growthRate());
                ds.field("baselineGrowth", &self.baselineGrowth());
                ds.field("notoriety", &self.notoriety());
                ds.field("sentimentKnowledge", &self.sentimentKnowledge());
                ds.field("sentimentTrust", &self.sentimentTrust());
                ds.field("sentimentEquity", &self.sentimentEquity());
                ds.field("sentimentAgency", &self.sentimentAgency());
                ds.field("sentimentWeightKnowledge", &self.sentimentWeightKnowledge());
                ds.field("sentimentWeightTrust", &self.sentimentWeightTrust());
                ds.field("sentimentWeightEquity", &self.sentimentWeightEquity());
                ds.field("sentimentWeightAgency", &self.sentimentWeightAgency());
                ds.field("logisticsBonus", &self.logisticsBonus());
                ds.field("moraleBonus", &self.moraleBonus());
                ds.field("powerBonus", &self.powerBonus());
                ds.field("logisticsWeight", &self.logisticsWeight());
                ds.field("moraleWeight", &self.moraleWeight());
                ds.field("powerWeight", &self.powerWeight());
                ds.field("supportCharge", &self.supportCharge());
                ds.field("suppressPressure", &self.suppressPressure());
                ds.field("domains", &self.domains());
                ds.field("scope", &self.scope());
                ds.field("generationScope", &self.generationScope());
                ds.field("supported", &self.supported());
                ds.field("suppressed", &self.suppressed());
                ds.field("lifecycle", &self.lifecycle());
                ds.field("coherence", &self.coherence());
                ds.field("ticksInStatus", &self.ticksInStatus());
                ds.field("audienceGenerations", &self.audienceGenerations());
                ds.field("supportPopular", &self.supportPopular());
                ds.field("supportPeer", &self.supportPeer());
                ds.field("supportInstitutional", &self.supportInstitutional());
                ds.field("supportHumanitarian", &self.supportHumanitarian());
                ds.field("weightPopular", &self.weightPopular());
                ds.field("weightPeer", &self.weightPeer());
                ds.field("weightInstitutional", &self.weightInstitutional());
                ds.field("weightHumanitarian", &self.weightHumanitarian());
                ds.field("cultureResonance", &self.cultureResonance());
                ds.finish()
            }
        }
        pub enum InfluencerCultureResonanceEntryOffset {}
        #[derive(Copy, Clone, PartialEq)]

        pub struct InfluencerCultureResonanceEntry<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for InfluencerCultureResonanceEntry<'a> {
            type Inner = InfluencerCultureResonanceEntry<'a>;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: unsafe { flatbuffers::Table::new(buf, loc) },
                }
            }
        }

        impl<'a> InfluencerCultureResonanceEntry<'a> {
            pub const VT_AXIS: flatbuffers::VOffsetT = 4;
            pub const VT_WEIGHT: flatbuffers::VOffsetT = 6;
            pub const VT_OUTPUT: flatbuffers::VOffsetT = 8;

            #[inline]
            pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                InfluencerCultureResonanceEntry { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<
                'bldr: 'args,
                'args: 'mut_bldr,
                'mut_bldr,
                A: flatbuffers::Allocator + 'bldr,
            >(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
                args: &'args InfluencerCultureResonanceEntryArgs,
            ) -> flatbuffers::WIPOffset<InfluencerCultureResonanceEntry<'bldr>> {
                let mut builder = InfluencerCultureResonanceEntryBuilder::new(_fbb);
                builder.add_output(args.output);
                builder.add_weight(args.weight);
                builder.add_axis(args.axis);
                builder.finish()
            }

            #[inline]
            pub fn axis(&self) -> CultureTraitAxis {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<CultureTraitAxis>(
                            InfluencerCultureResonanceEntry::VT_AXIS,
                            Some(CultureTraitAxis::PassiveAggressive),
                        )
                        .unwrap()
                }
            }
            #[inline]
            pub fn weight(&self) -> i64 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<i64>(InfluencerCultureResonanceEntry::VT_WEIGHT, Some(0))
                        .unwrap()
                }
            }
            #[inline]
            pub fn output(&self) -> i64 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<i64>(InfluencerCultureResonanceEntry::VT_OUTPUT, Some(0))
                        .unwrap()
                }
            }
        }

        impl flatbuffers::Verifiable for InfluencerCultureResonanceEntry<'_> {
            #[inline]
            fn run_verifier(
                v: &mut flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                v.visit_table(pos)?
                    .visit_field::<CultureTraitAxis>("axis", Self::VT_AXIS, false)?
                    .visit_field::<i64>("weight", Self::VT_WEIGHT, false)?
                    .visit_field::<i64>("output", Self::VT_OUTPUT, false)?
                    .finish();
                Ok(())
            }
        }
        pub struct InfluencerCultureResonanceEntryArgs {
            pub axis: CultureTraitAxis,
            pub weight: i64,
            pub output: i64,
        }
        impl<'a> Default for InfluencerCultureResonanceEntryArgs {
            #[inline]
            fn default() -> Self {
                InfluencerCultureResonanceEntryArgs {
                    axis: CultureTraitAxis::PassiveAggressive,
                    weight: 0,
                    output: 0,
                }
            }
        }

        pub struct InfluencerCultureResonanceEntryBuilder<
            'a: 'b,
            'b,
            A: flatbuffers::Allocator + 'a,
        > {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> InfluencerCultureResonanceEntryBuilder<'a, 'b, A> {
            #[inline]
            pub fn add_axis(&mut self, axis: CultureTraitAxis) {
                self.fbb_.push_slot::<CultureTraitAxis>(
                    InfluencerCultureResonanceEntry::VT_AXIS,
                    axis,
                    CultureTraitAxis::PassiveAggressive,
                );
            }
            #[inline]
            pub fn add_weight(&mut self, weight: i64) {
                self.fbb_
                    .push_slot::<i64>(InfluencerCultureResonanceEntry::VT_WEIGHT, weight, 0);
            }
            #[inline]
            pub fn add_output(&mut self, output: i64) {
                self.fbb_
                    .push_slot::<i64>(InfluencerCultureResonanceEntry::VT_OUTPUT, output, 0);
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
            ) -> InfluencerCultureResonanceEntryBuilder<'a, 'b, A> {
                let start = _fbb.start_table();
                InfluencerCultureResonanceEntryBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<InfluencerCultureResonanceEntry<'a>> {
                let o = self.fbb_.end_table(self.start_);
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        impl core::fmt::Debug for InfluencerCultureResonanceEntry<'_> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                let mut ds = f.debug_struct("InfluencerCultureResonanceEntry");
                ds.field("axis", &self.axis());
                ds.field("weight", &self.weight());
                ds.field("output", &self.output());
                ds.finish()
            }
        }
        pub enum CultureTraitEntryOffset {}
        #[derive(Copy, Clone, PartialEq)]

        pub struct CultureTraitEntry<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for CultureTraitEntry<'a> {
            type Inner = CultureTraitEntry<'a>;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: unsafe { flatbuffers::Table::new(buf, loc) },
                }
            }
        }

        impl<'a> CultureTraitEntry<'a> {
            pub const VT_AXIS: flatbuffers::VOffsetT = 4;
            pub const VT_BASELINE: flatbuffers::VOffsetT = 6;
            pub const VT_MODIFIER: flatbuffers::VOffsetT = 8;
            pub const VT_VALUE: flatbuffers::VOffsetT = 10;

            #[inline]
            pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                CultureTraitEntry { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<
                'bldr: 'args,
                'args: 'mut_bldr,
                'mut_bldr,
                A: flatbuffers::Allocator + 'bldr,
            >(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
                args: &'args CultureTraitEntryArgs,
            ) -> flatbuffers::WIPOffset<CultureTraitEntry<'bldr>> {
                let mut builder = CultureTraitEntryBuilder::new(_fbb);
                builder.add_value(args.value);
                builder.add_modifier(args.modifier);
                builder.add_baseline(args.baseline);
                builder.add_axis(args.axis);
                builder.finish()
            }

            #[inline]
            pub fn axis(&self) -> CultureTraitAxis {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<CultureTraitAxis>(
                            CultureTraitEntry::VT_AXIS,
                            Some(CultureTraitAxis::PassiveAggressive),
                        )
                        .unwrap()
                }
            }
            #[inline]
            pub fn baseline(&self) -> i64 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<i64>(CultureTraitEntry::VT_BASELINE, Some(0))
                        .unwrap()
                }
            }
            #[inline]
            pub fn modifier(&self) -> i64 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<i64>(CultureTraitEntry::VT_MODIFIER, Some(0))
                        .unwrap()
                }
            }
            #[inline]
            pub fn value(&self) -> i64 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<i64>(CultureTraitEntry::VT_VALUE, Some(0))
                        .unwrap()
                }
            }
        }

        impl flatbuffers::Verifiable for CultureTraitEntry<'_> {
            #[inline]
            fn run_verifier(
                v: &mut flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                v.visit_table(pos)?
                    .visit_field::<CultureTraitAxis>("axis", Self::VT_AXIS, false)?
                    .visit_field::<i64>("baseline", Self::VT_BASELINE, false)?
                    .visit_field::<i64>("modifier", Self::VT_MODIFIER, false)?
                    .visit_field::<i64>("value", Self::VT_VALUE, false)?
                    .finish();
                Ok(())
            }
        }
        pub struct CultureTraitEntryArgs {
            pub axis: CultureTraitAxis,
            pub baseline: i64,
            pub modifier: i64,
            pub value: i64,
        }
        impl<'a> Default for CultureTraitEntryArgs {
            #[inline]
            fn default() -> Self {
                CultureTraitEntryArgs {
                    axis: CultureTraitAxis::PassiveAggressive,
                    baseline: 0,
                    modifier: 0,
                    value: 0,
                }
            }
        }

        pub struct CultureTraitEntryBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> CultureTraitEntryBuilder<'a, 'b, A> {
            #[inline]
            pub fn add_axis(&mut self, axis: CultureTraitAxis) {
                self.fbb_.push_slot::<CultureTraitAxis>(
                    CultureTraitEntry::VT_AXIS,
                    axis,
                    CultureTraitAxis::PassiveAggressive,
                );
            }
            #[inline]
            pub fn add_baseline(&mut self, baseline: i64) {
                self.fbb_
                    .push_slot::<i64>(CultureTraitEntry::VT_BASELINE, baseline, 0);
            }
            #[inline]
            pub fn add_modifier(&mut self, modifier: i64) {
                self.fbb_
                    .push_slot::<i64>(CultureTraitEntry::VT_MODIFIER, modifier, 0);
            }
            #[inline]
            pub fn add_value(&mut self, value: i64) {
                self.fbb_
                    .push_slot::<i64>(CultureTraitEntry::VT_VALUE, value, 0);
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
            ) -> CultureTraitEntryBuilder<'a, 'b, A> {
                let start = _fbb.start_table();
                CultureTraitEntryBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<CultureTraitEntry<'a>> {
                let o = self.fbb_.end_table(self.start_);
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        impl core::fmt::Debug for CultureTraitEntry<'_> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                let mut ds = f.debug_struct("CultureTraitEntry");
                ds.field("axis", &self.axis());
                ds.field("baseline", &self.baseline());
                ds.field("modifier", &self.modifier());
                ds.field("value", &self.value());
                ds.finish()
            }
        }
        pub enum CultureLayerStateOffset {}
        #[derive(Copy, Clone, PartialEq)]

        pub struct CultureLayerState<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for CultureLayerState<'a> {
            type Inner = CultureLayerState<'a>;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: unsafe { flatbuffers::Table::new(buf, loc) },
                }
            }
        }

        impl<'a> CultureLayerState<'a> {
            pub const VT_ID: flatbuffers::VOffsetT = 4;
            pub const VT_OWNER: flatbuffers::VOffsetT = 6;
            pub const VT_PARENT: flatbuffers::VOffsetT = 8;
            pub const VT_SCOPE: flatbuffers::VOffsetT = 10;
            pub const VT_TRAITS: flatbuffers::VOffsetT = 12;
            pub const VT_DIVERGENCE: flatbuffers::VOffsetT = 14;
            pub const VT_SOFTTHRESHOLD: flatbuffers::VOffsetT = 16;
            pub const VT_HARDTHRESHOLD: flatbuffers::VOffsetT = 18;
            pub const VT_TICKSABOVESOFT: flatbuffers::VOffsetT = 20;
            pub const VT_TICKSABOVEHARD: flatbuffers::VOffsetT = 22;
            pub const VT_LASTUPDATEDTICK: flatbuffers::VOffsetT = 24;

            #[inline]
            pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                CultureLayerState { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<
                'bldr: 'args,
                'args: 'mut_bldr,
                'mut_bldr,
                A: flatbuffers::Allocator + 'bldr,
            >(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
                args: &'args CultureLayerStateArgs<'args>,
            ) -> flatbuffers::WIPOffset<CultureLayerState<'bldr>> {
                let mut builder = CultureLayerStateBuilder::new(_fbb);
                builder.add_lastUpdatedTick(args.lastUpdatedTick);
                builder.add_hardThreshold(args.hardThreshold);
                builder.add_softThreshold(args.softThreshold);
                builder.add_divergence(args.divergence);
                builder.add_owner(args.owner);
                if let Some(x) = args.traits {
                    builder.add_traits(x);
                }
                builder.add_parent(args.parent);
                builder.add_id(args.id);
                builder.add_ticksAboveHard(args.ticksAboveHard);
                builder.add_ticksAboveSoft(args.ticksAboveSoft);
                builder.add_scope(args.scope);
                builder.finish()
            }

            #[inline]
            pub fn id(&self) -> u32 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<u32>(CultureLayerState::VT_ID, Some(0))
                        .unwrap()
                }
            }
            #[inline]
            pub fn owner(&self) -> u64 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<u64>(CultureLayerState::VT_OWNER, Some(0))
                        .unwrap()
                }
            }
            #[inline]
            pub fn parent(&self) -> u32 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<u32>(CultureLayerState::VT_PARENT, Some(0))
                        .unwrap()
                }
            }
            #[inline]
            pub fn scope(&self) -> CultureLayerScope {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<CultureLayerScope>(
                            CultureLayerState::VT_SCOPE,
                            Some(CultureLayerScope::Global),
                        )
                        .unwrap()
                }
            }
            #[inline]
            pub fn traits(
                &self,
            ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<CultureTraitEntry<'a>>>>
            {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab.get::<flatbuffers::ForwardsUOffset<
                        flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<CultureTraitEntry>>,
                    >>(CultureLayerState::VT_TRAITS, None)
                }
            }
            #[inline]
            pub fn divergence(&self) -> i64 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<i64>(CultureLayerState::VT_DIVERGENCE, Some(0))
                        .unwrap()
                }
            }
            #[inline]
            pub fn softThreshold(&self) -> i64 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<i64>(CultureLayerState::VT_SOFTTHRESHOLD, Some(0))
                        .unwrap()
                }
            }
            #[inline]
            pub fn hardThreshold(&self) -> i64 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<i64>(CultureLayerState::VT_HARDTHRESHOLD, Some(0))
                        .unwrap()
                }
            }
            #[inline]
            pub fn ticksAboveSoft(&self) -> u16 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<u16>(CultureLayerState::VT_TICKSABOVESOFT, Some(0))
                        .unwrap()
                }
            }
            #[inline]
            pub fn ticksAboveHard(&self) -> u16 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<u16>(CultureLayerState::VT_TICKSABOVEHARD, Some(0))
                        .unwrap()
                }
            }
            #[inline]
            pub fn lastUpdatedTick(&self) -> u64 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<u64>(CultureLayerState::VT_LASTUPDATEDTICK, Some(0))
                        .unwrap()
                }
            }
        }

        impl flatbuffers::Verifiable for CultureLayerState<'_> {
            #[inline]
            fn run_verifier(
                v: &mut flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                v.visit_table(pos)?
                    .visit_field::<u32>("id", Self::VT_ID, false)?
                    .visit_field::<u64>("owner", Self::VT_OWNER, false)?
                    .visit_field::<u32>("parent", Self::VT_PARENT, false)?
                    .visit_field::<CultureLayerScope>("scope", Self::VT_SCOPE, false)?
                    .visit_field::<flatbuffers::ForwardsUOffset<
                        flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<CultureTraitEntry>>,
                    >>("traits", Self::VT_TRAITS, false)?
                    .visit_field::<i64>("divergence", Self::VT_DIVERGENCE, false)?
                    .visit_field::<i64>("softThreshold", Self::VT_SOFTTHRESHOLD, false)?
                    .visit_field::<i64>("hardThreshold", Self::VT_HARDTHRESHOLD, false)?
                    .visit_field::<u16>("ticksAboveSoft", Self::VT_TICKSABOVESOFT, false)?
                    .visit_field::<u16>("ticksAboveHard", Self::VT_TICKSABOVEHARD, false)?
                    .visit_field::<u64>("lastUpdatedTick", Self::VT_LASTUPDATEDTICK, false)?
                    .finish();
                Ok(())
            }
        }
        pub struct CultureLayerStateArgs<'a> {
            pub id: u32,
            pub owner: u64,
            pub parent: u32,
            pub scope: CultureLayerScope,
            pub traits: Option<
                flatbuffers::WIPOffset<
                    flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<CultureTraitEntry<'a>>>,
                >,
            >,
            pub divergence: i64,
            pub softThreshold: i64,
            pub hardThreshold: i64,
            pub ticksAboveSoft: u16,
            pub ticksAboveHard: u16,
            pub lastUpdatedTick: u64,
        }
        impl<'a> Default for CultureLayerStateArgs<'a> {
            #[inline]
            fn default() -> Self {
                CultureLayerStateArgs {
                    id: 0,
                    owner: 0,
                    parent: 0,
                    scope: CultureLayerScope::Global,
                    traits: None,
                    divergence: 0,
                    softThreshold: 0,
                    hardThreshold: 0,
                    ticksAboveSoft: 0,
                    ticksAboveHard: 0,
                    lastUpdatedTick: 0,
                }
            }
        }

        pub struct CultureLayerStateBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> CultureLayerStateBuilder<'a, 'b, A> {
            #[inline]
            pub fn add_id(&mut self, id: u32) {
                self.fbb_.push_slot::<u32>(CultureLayerState::VT_ID, id, 0);
            }
            #[inline]
            pub fn add_owner(&mut self, owner: u64) {
                self.fbb_
                    .push_slot::<u64>(CultureLayerState::VT_OWNER, owner, 0);
            }
            #[inline]
            pub fn add_parent(&mut self, parent: u32) {
                self.fbb_
                    .push_slot::<u32>(CultureLayerState::VT_PARENT, parent, 0);
            }
            #[inline]
            pub fn add_scope(&mut self, scope: CultureLayerScope) {
                self.fbb_.push_slot::<CultureLayerScope>(
                    CultureLayerState::VT_SCOPE,
                    scope,
                    CultureLayerScope::Global,
                );
            }
            #[inline]
            pub fn add_traits(
                &mut self,
                traits: flatbuffers::WIPOffset<
                    flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<CultureTraitEntry<'b>>>,
                >,
            ) {
                self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                    CultureLayerState::VT_TRAITS,
                    traits,
                );
            }
            #[inline]
            pub fn add_divergence(&mut self, divergence: i64) {
                self.fbb_
                    .push_slot::<i64>(CultureLayerState::VT_DIVERGENCE, divergence, 0);
            }
            #[inline]
            pub fn add_softThreshold(&mut self, softThreshold: i64) {
                self.fbb_
                    .push_slot::<i64>(CultureLayerState::VT_SOFTTHRESHOLD, softThreshold, 0);
            }
            #[inline]
            pub fn add_hardThreshold(&mut self, hardThreshold: i64) {
                self.fbb_
                    .push_slot::<i64>(CultureLayerState::VT_HARDTHRESHOLD, hardThreshold, 0);
            }
            #[inline]
            pub fn add_ticksAboveSoft(&mut self, ticksAboveSoft: u16) {
                self.fbb_
                    .push_slot::<u16>(CultureLayerState::VT_TICKSABOVESOFT, ticksAboveSoft, 0);
            }
            #[inline]
            pub fn add_ticksAboveHard(&mut self, ticksAboveHard: u16) {
                self.fbb_
                    .push_slot::<u16>(CultureLayerState::VT_TICKSABOVEHARD, ticksAboveHard, 0);
            }
            #[inline]
            pub fn add_lastUpdatedTick(&mut self, lastUpdatedTick: u64) {
                self.fbb_.push_slot::<u64>(
                    CultureLayerState::VT_LASTUPDATEDTICK,
                    lastUpdatedTick,
                    0,
                );
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
            ) -> CultureLayerStateBuilder<'a, 'b, A> {
                let start = _fbb.start_table();
                CultureLayerStateBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<CultureLayerState<'a>> {
                let o = self.fbb_.end_table(self.start_);
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        impl core::fmt::Debug for CultureLayerState<'_> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                let mut ds = f.debug_struct("CultureLayerState");
                ds.field("id", &self.id());
                ds.field("owner", &self.owner());
                ds.field("parent", &self.parent());
                ds.field("scope", &self.scope());
                ds.field("traits", &self.traits());
                ds.field("divergence", &self.divergence());
                ds.field("softThreshold", &self.softThreshold());
                ds.field("hardThreshold", &self.hardThreshold());
                ds.field("ticksAboveSoft", &self.ticksAboveSoft());
                ds.field("ticksAboveHard", &self.ticksAboveHard());
                ds.field("lastUpdatedTick", &self.lastUpdatedTick());
                ds.finish()
            }
        }
        pub enum CultureTensionStateOffset {}
        #[derive(Copy, Clone, PartialEq)]

        pub struct CultureTensionState<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for CultureTensionState<'a> {
            type Inner = CultureTensionState<'a>;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: unsafe { flatbuffers::Table::new(buf, loc) },
                }
            }
        }

        impl<'a> CultureTensionState<'a> {
            pub const VT_LAYERID: flatbuffers::VOffsetT = 4;
            pub const VT_SCOPE: flatbuffers::VOffsetT = 6;
            pub const VT_OWNER: flatbuffers::VOffsetT = 8;
            pub const VT_SEVERITY: flatbuffers::VOffsetT = 10;
            pub const VT_TIMER: flatbuffers::VOffsetT = 12;
            pub const VT_KIND: flatbuffers::VOffsetT = 14;

            #[inline]
            pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                CultureTensionState { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<
                'bldr: 'args,
                'args: 'mut_bldr,
                'mut_bldr,
                A: flatbuffers::Allocator + 'bldr,
            >(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
                args: &'args CultureTensionStateArgs,
            ) -> flatbuffers::WIPOffset<CultureTensionState<'bldr>> {
                let mut builder = CultureTensionStateBuilder::new(_fbb);
                builder.add_severity(args.severity);
                builder.add_owner(args.owner);
                builder.add_layerId(args.layerId);
                builder.add_timer(args.timer);
                builder.add_kind(args.kind);
                builder.add_scope(args.scope);
                builder.finish()
            }

            #[inline]
            pub fn layerId(&self) -> u32 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<u32>(CultureTensionState::VT_LAYERID, Some(0))
                        .unwrap()
                }
            }
            #[inline]
            pub fn scope(&self) -> CultureLayerScope {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<CultureLayerScope>(
                            CultureTensionState::VT_SCOPE,
                            Some(CultureLayerScope::Global),
                        )
                        .unwrap()
                }
            }
            #[inline]
            pub fn owner(&self) -> u64 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<u64>(CultureTensionState::VT_OWNER, Some(0))
                        .unwrap()
                }
            }
            #[inline]
            pub fn severity(&self) -> i64 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<i64>(CultureTensionState::VT_SEVERITY, Some(0))
                        .unwrap()
                }
            }
            #[inline]
            pub fn timer(&self) -> u16 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<u16>(CultureTensionState::VT_TIMER, Some(0))
                        .unwrap()
                }
            }
            #[inline]
            pub fn kind(&self) -> CultureTensionKind {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<CultureTensionKind>(
                            CultureTensionState::VT_KIND,
                            Some(CultureTensionKind::DriftWarning),
                        )
                        .unwrap()
                }
            }
        }

        impl flatbuffers::Verifiable for CultureTensionState<'_> {
            #[inline]
            fn run_verifier(
                v: &mut flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                v.visit_table(pos)?
                    .visit_field::<u32>("layerId", Self::VT_LAYERID, false)?
                    .visit_field::<CultureLayerScope>("scope", Self::VT_SCOPE, false)?
                    .visit_field::<u64>("owner", Self::VT_OWNER, false)?
                    .visit_field::<i64>("severity", Self::VT_SEVERITY, false)?
                    .visit_field::<u16>("timer", Self::VT_TIMER, false)?
                    .visit_field::<CultureTensionKind>("kind", Self::VT_KIND, false)?
                    .finish();
                Ok(())
            }
        }
        pub struct CultureTensionStateArgs {
            pub layerId: u32,
            pub scope: CultureLayerScope,
            pub owner: u64,
            pub severity: i64,
            pub timer: u16,
            pub kind: CultureTensionKind,
        }
        impl<'a> Default for CultureTensionStateArgs {
            #[inline]
            fn default() -> Self {
                CultureTensionStateArgs {
                    layerId: 0,
                    scope: CultureLayerScope::Global,
                    owner: 0,
                    severity: 0,
                    timer: 0,
                    kind: CultureTensionKind::DriftWarning,
                }
            }
        }

        pub struct CultureTensionStateBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> CultureTensionStateBuilder<'a, 'b, A> {
            #[inline]
            pub fn add_layerId(&mut self, layerId: u32) {
                self.fbb_
                    .push_slot::<u32>(CultureTensionState::VT_LAYERID, layerId, 0);
            }
            #[inline]
            pub fn add_scope(&mut self, scope: CultureLayerScope) {
                self.fbb_.push_slot::<CultureLayerScope>(
                    CultureTensionState::VT_SCOPE,
                    scope,
                    CultureLayerScope::Global,
                );
            }
            #[inline]
            pub fn add_owner(&mut self, owner: u64) {
                self.fbb_
                    .push_slot::<u64>(CultureTensionState::VT_OWNER, owner, 0);
            }
            #[inline]
            pub fn add_severity(&mut self, severity: i64) {
                self.fbb_
                    .push_slot::<i64>(CultureTensionState::VT_SEVERITY, severity, 0);
            }
            #[inline]
            pub fn add_timer(&mut self, timer: u16) {
                self.fbb_
                    .push_slot::<u16>(CultureTensionState::VT_TIMER, timer, 0);
            }
            #[inline]
            pub fn add_kind(&mut self, kind: CultureTensionKind) {
                self.fbb_.push_slot::<CultureTensionKind>(
                    CultureTensionState::VT_KIND,
                    kind,
                    CultureTensionKind::DriftWarning,
                );
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
            ) -> CultureTensionStateBuilder<'a, 'b, A> {
                let start = _fbb.start_table();
                CultureTensionStateBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<CultureTensionState<'a>> {
                let o = self.fbb_.end_table(self.start_);
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        impl core::fmt::Debug for CultureTensionState<'_> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                let mut ds = f.debug_struct("CultureTensionState");
                ds.field("layerId", &self.layerId());
                ds.field("scope", &self.scope());
                ds.field("owner", &self.owner());
                ds.field("severity", &self.severity());
                ds.field("timer", &self.timer());
                ds.field("kind", &self.kind());
                ds.finish()
            }
        }
        pub enum TileStateOffset {}
        #[derive(Copy, Clone, PartialEq)]

        pub struct TileState<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for TileState<'a> {
            type Inner = TileState<'a>;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: unsafe { flatbuffers::Table::new(buf, loc) },
                }
            }
        }

        impl<'a> TileState<'a> {
            pub const VT_ENTITY: flatbuffers::VOffsetT = 4;
            pub const VT_X: flatbuffers::VOffsetT = 6;
            pub const VT_Y: flatbuffers::VOffsetT = 8;
            pub const VT_ELEMENT: flatbuffers::VOffsetT = 10;
            pub const VT_MASS: flatbuffers::VOffsetT = 12;
            pub const VT_TEMPERATURE: flatbuffers::VOffsetT = 14;
            pub const VT_TERRAIN: flatbuffers::VOffsetT = 16;
            pub const VT_TERRAINTAGS: flatbuffers::VOffsetT = 18;

            #[inline]
            pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                TileState { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<
                'bldr: 'args,
                'args: 'mut_bldr,
                'mut_bldr,
                A: flatbuffers::Allocator + 'bldr,
            >(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
                args: &'args TileStateArgs,
            ) -> flatbuffers::WIPOffset<TileState<'bldr>> {
                let mut builder = TileStateBuilder::new(_fbb);
                builder.add_temperature(args.temperature);
                builder.add_mass(args.mass);
                builder.add_entity(args.entity);
                builder.add_y(args.y);
                builder.add_x(args.x);
                builder.add_terrainTags(args.terrainTags);
                builder.add_terrain(args.terrain);
                builder.add_element(args.element);
                builder.finish()
            }

            #[inline]
            pub fn entity(&self) -> u64 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe { self._tab.get::<u64>(TileState::VT_ENTITY, Some(0)).unwrap() }
            }
            #[inline]
            pub fn x(&self) -> u32 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe { self._tab.get::<u32>(TileState::VT_X, Some(0)).unwrap() }
            }
            #[inline]
            pub fn y(&self) -> u32 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe { self._tab.get::<u32>(TileState::VT_Y, Some(0)).unwrap() }
            }
            #[inline]
            pub fn element(&self) -> u8 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe { self._tab.get::<u8>(TileState::VT_ELEMENT, Some(0)).unwrap() }
            }
            #[inline]
            pub fn mass(&self) -> i64 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe { self._tab.get::<i64>(TileState::VT_MASS, Some(0)).unwrap() }
            }
            #[inline]
            pub fn temperature(&self) -> i64 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<i64>(TileState::VT_TEMPERATURE, Some(0))
                        .unwrap()
                }
            }
            #[inline]
            pub fn terrain(&self) -> TerrainType {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<TerrainType>(TileState::VT_TERRAIN, Some(TerrainType::DeepOcean))
                        .unwrap()
                }
            }
            #[inline]
            pub fn terrainTags(&self) -> u16 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<u16>(TileState::VT_TERRAINTAGS, Some(0))
                        .unwrap()
                }
            }
        }

        impl flatbuffers::Verifiable for TileState<'_> {
            #[inline]
            fn run_verifier(
                v: &mut flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                v.visit_table(pos)?
                    .visit_field::<u64>("entity", Self::VT_ENTITY, false)?
                    .visit_field::<u32>("x", Self::VT_X, false)?
                    .visit_field::<u32>("y", Self::VT_Y, false)?
                    .visit_field::<u8>("element", Self::VT_ELEMENT, false)?
                    .visit_field::<i64>("mass", Self::VT_MASS, false)?
                    .visit_field::<i64>("temperature", Self::VT_TEMPERATURE, false)?
                    .visit_field::<TerrainType>("terrain", Self::VT_TERRAIN, false)?
                    .visit_field::<u16>("terrainTags", Self::VT_TERRAINTAGS, false)?
                    .finish();
                Ok(())
            }
        }
        pub struct TileStateArgs {
            pub entity: u64,
            pub x: u32,
            pub y: u32,
            pub element: u8,
            pub mass: i64,
            pub temperature: i64,
            pub terrain: TerrainType,
            pub terrainTags: u16,
        }
        impl<'a> Default for TileStateArgs {
            #[inline]
            fn default() -> Self {
                TileStateArgs {
                    entity: 0,
                    x: 0,
                    y: 0,
                    element: 0,
                    mass: 0,
                    temperature: 0,
                    terrain: TerrainType::DeepOcean,
                    terrainTags: 0,
                }
            }
        }

        pub struct TileStateBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> TileStateBuilder<'a, 'b, A> {
            #[inline]
            pub fn add_entity(&mut self, entity: u64) {
                self.fbb_.push_slot::<u64>(TileState::VT_ENTITY, entity, 0);
            }
            #[inline]
            pub fn add_x(&mut self, x: u32) {
                self.fbb_.push_slot::<u32>(TileState::VT_X, x, 0);
            }
            #[inline]
            pub fn add_y(&mut self, y: u32) {
                self.fbb_.push_slot::<u32>(TileState::VT_Y, y, 0);
            }
            #[inline]
            pub fn add_element(&mut self, element: u8) {
                self.fbb_.push_slot::<u8>(TileState::VT_ELEMENT, element, 0);
            }
            #[inline]
            pub fn add_mass(&mut self, mass: i64) {
                self.fbb_.push_slot::<i64>(TileState::VT_MASS, mass, 0);
            }
            #[inline]
            pub fn add_temperature(&mut self, temperature: i64) {
                self.fbb_
                    .push_slot::<i64>(TileState::VT_TEMPERATURE, temperature, 0);
            }
            #[inline]
            pub fn add_terrain(&mut self, terrain: TerrainType) {
                self.fbb_.push_slot::<TerrainType>(
                    TileState::VT_TERRAIN,
                    terrain,
                    TerrainType::DeepOcean,
                );
            }
            #[inline]
            pub fn add_terrainTags(&mut self, terrainTags: u16) {
                self.fbb_
                    .push_slot::<u16>(TileState::VT_TERRAINTAGS, terrainTags, 0);
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
            ) -> TileStateBuilder<'a, 'b, A> {
                let start = _fbb.start_table();
                TileStateBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<TileState<'a>> {
                let o = self.fbb_.end_table(self.start_);
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        impl core::fmt::Debug for TileState<'_> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                let mut ds = f.debug_struct("TileState");
                ds.field("entity", &self.entity());
                ds.field("x", &self.x());
                ds.field("y", &self.y());
                ds.field("element", &self.element());
                ds.field("mass", &self.mass());
                ds.field("temperature", &self.temperature());
                ds.field("terrain", &self.terrain());
                ds.field("terrainTags", &self.terrainTags());
                ds.finish()
            }
        }
        pub enum LogisticsLinkStateOffset {}
        #[derive(Copy, Clone, PartialEq)]

        pub struct LogisticsLinkState<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for LogisticsLinkState<'a> {
            type Inner = LogisticsLinkState<'a>;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: unsafe { flatbuffers::Table::new(buf, loc) },
                }
            }
        }

        impl<'a> LogisticsLinkState<'a> {
            pub const VT_ENTITY: flatbuffers::VOffsetT = 4;
            pub const VT_FROM: flatbuffers::VOffsetT = 6;
            pub const VT_TO: flatbuffers::VOffsetT = 8;
            pub const VT_CAPACITY: flatbuffers::VOffsetT = 10;
            pub const VT_FLOW: flatbuffers::VOffsetT = 12;

            #[inline]
            pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                LogisticsLinkState { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<
                'bldr: 'args,
                'args: 'mut_bldr,
                'mut_bldr,
                A: flatbuffers::Allocator + 'bldr,
            >(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
                args: &'args LogisticsLinkStateArgs,
            ) -> flatbuffers::WIPOffset<LogisticsLinkState<'bldr>> {
                let mut builder = LogisticsLinkStateBuilder::new(_fbb);
                builder.add_flow(args.flow);
                builder.add_capacity(args.capacity);
                builder.add_to(args.to);
                builder.add_from(args.from);
                builder.add_entity(args.entity);
                builder.finish()
            }

            #[inline]
            pub fn entity(&self) -> u64 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<u64>(LogisticsLinkState::VT_ENTITY, Some(0))
                        .unwrap()
                }
            }
            #[inline]
            pub fn from(&self) -> u64 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<u64>(LogisticsLinkState::VT_FROM, Some(0))
                        .unwrap()
                }
            }
            #[inline]
            pub fn to(&self) -> u64 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<u64>(LogisticsLinkState::VT_TO, Some(0))
                        .unwrap()
                }
            }
            #[inline]
            pub fn capacity(&self) -> i64 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<i64>(LogisticsLinkState::VT_CAPACITY, Some(0))
                        .unwrap()
                }
            }
            #[inline]
            pub fn flow(&self) -> i64 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<i64>(LogisticsLinkState::VT_FLOW, Some(0))
                        .unwrap()
                }
            }
        }

        impl flatbuffers::Verifiable for LogisticsLinkState<'_> {
            #[inline]
            fn run_verifier(
                v: &mut flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                v.visit_table(pos)?
                    .visit_field::<u64>("entity", Self::VT_ENTITY, false)?
                    .visit_field::<u64>("from", Self::VT_FROM, false)?
                    .visit_field::<u64>("to", Self::VT_TO, false)?
                    .visit_field::<i64>("capacity", Self::VT_CAPACITY, false)?
                    .visit_field::<i64>("flow", Self::VT_FLOW, false)?
                    .finish();
                Ok(())
            }
        }
        pub struct LogisticsLinkStateArgs {
            pub entity: u64,
            pub from: u64,
            pub to: u64,
            pub capacity: i64,
            pub flow: i64,
        }
        impl<'a> Default for LogisticsLinkStateArgs {
            #[inline]
            fn default() -> Self {
                LogisticsLinkStateArgs {
                    entity: 0,
                    from: 0,
                    to: 0,
                    capacity: 0,
                    flow: 0,
                }
            }
        }

        pub struct LogisticsLinkStateBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> LogisticsLinkStateBuilder<'a, 'b, A> {
            #[inline]
            pub fn add_entity(&mut self, entity: u64) {
                self.fbb_
                    .push_slot::<u64>(LogisticsLinkState::VT_ENTITY, entity, 0);
            }
            #[inline]
            pub fn add_from(&mut self, from: u64) {
                self.fbb_
                    .push_slot::<u64>(LogisticsLinkState::VT_FROM, from, 0);
            }
            #[inline]
            pub fn add_to(&mut self, to: u64) {
                self.fbb_.push_slot::<u64>(LogisticsLinkState::VT_TO, to, 0);
            }
            #[inline]
            pub fn add_capacity(&mut self, capacity: i64) {
                self.fbb_
                    .push_slot::<i64>(LogisticsLinkState::VT_CAPACITY, capacity, 0);
            }
            #[inline]
            pub fn add_flow(&mut self, flow: i64) {
                self.fbb_
                    .push_slot::<i64>(LogisticsLinkState::VT_FLOW, flow, 0);
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
            ) -> LogisticsLinkStateBuilder<'a, 'b, A> {
                let start = _fbb.start_table();
                LogisticsLinkStateBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<LogisticsLinkState<'a>> {
                let o = self.fbb_.end_table(self.start_);
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        impl core::fmt::Debug for LogisticsLinkState<'_> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                let mut ds = f.debug_struct("LogisticsLinkState");
                ds.field("entity", &self.entity());
                ds.field("from", &self.from());
                ds.field("to", &self.to());
                ds.field("capacity", &self.capacity());
                ds.field("flow", &self.flow());
                ds.finish()
            }
        }
        pub enum PopulationCohortStateOffset {}
        #[derive(Copy, Clone, PartialEq)]

        pub struct PopulationCohortState<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for PopulationCohortState<'a> {
            type Inner = PopulationCohortState<'a>;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: unsafe { flatbuffers::Table::new(buf, loc) },
                }
            }
        }

        impl<'a> PopulationCohortState<'a> {
            pub const VT_ENTITY: flatbuffers::VOffsetT = 4;
            pub const VT_HOME: flatbuffers::VOffsetT = 6;
            pub const VT_SIZE: flatbuffers::VOffsetT = 8;
            pub const VT_MORALE: flatbuffers::VOffsetT = 10;
            pub const VT_GENERATION: flatbuffers::VOffsetT = 12;
            pub const VT_FACTION: flatbuffers::VOffsetT = 14;
            pub const VT_KNOWLEDGEFRAGMENTS: flatbuffers::VOffsetT = 16;
            pub const VT_MIGRATION: flatbuffers::VOffsetT = 18;

            #[inline]
            pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                PopulationCohortState { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<
                'bldr: 'args,
                'args: 'mut_bldr,
                'mut_bldr,
                A: flatbuffers::Allocator + 'bldr,
            >(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
                args: &'args PopulationCohortStateArgs<'args>,
            ) -> flatbuffers::WIPOffset<PopulationCohortState<'bldr>> {
                let mut builder = PopulationCohortStateBuilder::new(_fbb);
                builder.add_morale(args.morale);
                builder.add_home(args.home);
                builder.add_entity(args.entity);
                if let Some(x) = args.migration {
                    builder.add_migration(x);
                }
                if let Some(x) = args.knowledgeFragments {
                    builder.add_knowledgeFragments(x);
                }
                builder.add_faction(args.faction);
                builder.add_size(args.size);
                builder.add_generation(args.generation);
                builder.finish()
            }

            #[inline]
            pub fn entity(&self) -> u64 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<u64>(PopulationCohortState::VT_ENTITY, Some(0))
                        .unwrap()
                }
            }
            #[inline]
            pub fn home(&self) -> u64 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<u64>(PopulationCohortState::VT_HOME, Some(0))
                        .unwrap()
                }
            }
            #[inline]
            pub fn size(&self) -> u32 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<u32>(PopulationCohortState::VT_SIZE, Some(0))
                        .unwrap()
                }
            }
            #[inline]
            pub fn morale(&self) -> i64 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<i64>(PopulationCohortState::VT_MORALE, Some(0))
                        .unwrap()
                }
            }
            #[inline]
            pub fn generation(&self) -> u16 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<u16>(PopulationCohortState::VT_GENERATION, Some(0))
                        .unwrap()
                }
            }
            #[inline]
            pub fn faction(&self) -> u32 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<u32>(PopulationCohortState::VT_FACTION, Some(0))
                        .unwrap()
                }
            }
            #[inline]
            pub fn knowledgeFragments(
                &self,
            ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<KnownTechFragment<'a>>>>
            {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab.get::<flatbuffers::ForwardsUOffset<
                        flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<KnownTechFragment>>,
                    >>(
                        PopulationCohortState::VT_KNOWLEDGEFRAGMENTS, None
                    )
                }
            }
            #[inline]
            pub fn migration(&self) -> Option<PendingMigration<'a>> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<flatbuffers::ForwardsUOffset<PendingMigration>>(
                            PopulationCohortState::VT_MIGRATION,
                            None,
                        )
                }
            }
        }

        impl flatbuffers::Verifiable for PopulationCohortState<'_> {
            #[inline]
            fn run_verifier(
                v: &mut flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                v.visit_table(pos)?
                    .visit_field::<u64>("entity", Self::VT_ENTITY, false)?
                    .visit_field::<u64>("home", Self::VT_HOME, false)?
                    .visit_field::<u32>("size", Self::VT_SIZE, false)?
                    .visit_field::<i64>("morale", Self::VT_MORALE, false)?
                    .visit_field::<u16>("generation", Self::VT_GENERATION, false)?
                    .visit_field::<u32>("faction", Self::VT_FACTION, false)?
                    .visit_field::<flatbuffers::ForwardsUOffset<
                        flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<KnownTechFragment>>,
                    >>("knowledgeFragments", Self::VT_KNOWLEDGEFRAGMENTS, false)?
                    .visit_field::<flatbuffers::ForwardsUOffset<PendingMigration>>(
                        "migration",
                        Self::VT_MIGRATION,
                        false,
                    )?
                    .finish();
                Ok(())
            }
        }
        pub struct PopulationCohortStateArgs<'a> {
            pub entity: u64,
            pub home: u64,
            pub size: u32,
            pub morale: i64,
            pub generation: u16,
            pub faction: u32,
            pub knowledgeFragments: Option<
                flatbuffers::WIPOffset<
                    flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<KnownTechFragment<'a>>>,
                >,
            >,
            pub migration: Option<flatbuffers::WIPOffset<PendingMigration<'a>>>,
        }
        impl<'a> Default for PopulationCohortStateArgs<'a> {
            #[inline]
            fn default() -> Self {
                PopulationCohortStateArgs {
                    entity: 0,
                    home: 0,
                    size: 0,
                    morale: 0,
                    generation: 0,
                    faction: 0,
                    knowledgeFragments: None,
                    migration: None,
                }
            }
        }

        pub struct PopulationCohortStateBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> PopulationCohortStateBuilder<'a, 'b, A> {
            #[inline]
            pub fn add_entity(&mut self, entity: u64) {
                self.fbb_
                    .push_slot::<u64>(PopulationCohortState::VT_ENTITY, entity, 0);
            }
            #[inline]
            pub fn add_home(&mut self, home: u64) {
                self.fbb_
                    .push_slot::<u64>(PopulationCohortState::VT_HOME, home, 0);
            }
            #[inline]
            pub fn add_size(&mut self, size: u32) {
                self.fbb_
                    .push_slot::<u32>(PopulationCohortState::VT_SIZE, size, 0);
            }
            #[inline]
            pub fn add_morale(&mut self, morale: i64) {
                self.fbb_
                    .push_slot::<i64>(PopulationCohortState::VT_MORALE, morale, 0);
            }
            #[inline]
            pub fn add_generation(&mut self, generation: u16) {
                self.fbb_
                    .push_slot::<u16>(PopulationCohortState::VT_GENERATION, generation, 0);
            }
            #[inline]
            pub fn add_faction(&mut self, faction: u32) {
                self.fbb_
                    .push_slot::<u32>(PopulationCohortState::VT_FACTION, faction, 0);
            }
            #[inline]
            pub fn add_knowledgeFragments(
                &mut self,
                knowledgeFragments: flatbuffers::WIPOffset<
                    flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<KnownTechFragment<'b>>>,
                >,
            ) {
                self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                    PopulationCohortState::VT_KNOWLEDGEFRAGMENTS,
                    knowledgeFragments,
                );
            }
            #[inline]
            pub fn add_migration(
                &mut self,
                migration: flatbuffers::WIPOffset<PendingMigration<'b>>,
            ) {
                self.fbb_
                    .push_slot_always::<flatbuffers::WIPOffset<PendingMigration>>(
                        PopulationCohortState::VT_MIGRATION,
                        migration,
                    );
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
            ) -> PopulationCohortStateBuilder<'a, 'b, A> {
                let start = _fbb.start_table();
                PopulationCohortStateBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<PopulationCohortState<'a>> {
                let o = self.fbb_.end_table(self.start_);
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        impl core::fmt::Debug for PopulationCohortState<'_> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                let mut ds = f.debug_struct("PopulationCohortState");
                ds.field("entity", &self.entity());
                ds.field("home", &self.home());
                ds.field("size", &self.size());
                ds.field("morale", &self.morale());
                ds.field("generation", &self.generation());
                ds.field("faction", &self.faction());
                ds.field("knowledgeFragments", &self.knowledgeFragments());
                ds.field("migration", &self.migration());
                ds.finish()
            }
        }
        pub enum PendingMigrationOffset {}
        #[derive(Copy, Clone, PartialEq)]

        pub struct PendingMigration<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for PendingMigration<'a> {
            type Inner = PendingMigration<'a>;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: unsafe { flatbuffers::Table::new(buf, loc) },
                }
            }
        }

        impl<'a> PendingMigration<'a> {
            pub const VT_DESTINATION: flatbuffers::VOffsetT = 4;
            pub const VT_ETA: flatbuffers::VOffsetT = 6;
            pub const VT_FRAGMENTS: flatbuffers::VOffsetT = 8;

            #[inline]
            pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                PendingMigration { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<
                'bldr: 'args,
                'args: 'mut_bldr,
                'mut_bldr,
                A: flatbuffers::Allocator + 'bldr,
            >(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
                args: &'args PendingMigrationArgs<'args>,
            ) -> flatbuffers::WIPOffset<PendingMigration<'bldr>> {
                let mut builder = PendingMigrationBuilder::new(_fbb);
                if let Some(x) = args.fragments {
                    builder.add_fragments(x);
                }
                builder.add_destination(args.destination);
                builder.add_eta(args.eta);
                builder.finish()
            }

            #[inline]
            pub fn destination(&self) -> u32 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<u32>(PendingMigration::VT_DESTINATION, Some(0))
                        .unwrap()
                }
            }
            #[inline]
            pub fn eta(&self) -> u16 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<u16>(PendingMigration::VT_ETA, Some(0))
                        .unwrap()
                }
            }
            #[inline]
            pub fn fragments(
                &self,
            ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<KnownTechFragment<'a>>>>
            {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab.get::<flatbuffers::ForwardsUOffset<
                        flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<KnownTechFragment>>,
                    >>(PendingMigration::VT_FRAGMENTS, None)
                }
            }
        }

        impl flatbuffers::Verifiable for PendingMigration<'_> {
            #[inline]
            fn run_verifier(
                v: &mut flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                v.visit_table(pos)?
                    .visit_field::<u32>("destination", Self::VT_DESTINATION, false)?
                    .visit_field::<u16>("eta", Self::VT_ETA, false)?
                    .visit_field::<flatbuffers::ForwardsUOffset<
                        flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<KnownTechFragment>>,
                    >>("fragments", Self::VT_FRAGMENTS, false)?
                    .finish();
                Ok(())
            }
        }
        pub struct PendingMigrationArgs<'a> {
            pub destination: u32,
            pub eta: u16,
            pub fragments: Option<
                flatbuffers::WIPOffset<
                    flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<KnownTechFragment<'a>>>,
                >,
            >,
        }
        impl<'a> Default for PendingMigrationArgs<'a> {
            #[inline]
            fn default() -> Self {
                PendingMigrationArgs {
                    destination: 0,
                    eta: 0,
                    fragments: None,
                }
            }
        }

        pub struct PendingMigrationBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> PendingMigrationBuilder<'a, 'b, A> {
            #[inline]
            pub fn add_destination(&mut self, destination: u32) {
                self.fbb_
                    .push_slot::<u32>(PendingMigration::VT_DESTINATION, destination, 0);
            }
            #[inline]
            pub fn add_eta(&mut self, eta: u16) {
                self.fbb_.push_slot::<u16>(PendingMigration::VT_ETA, eta, 0);
            }
            #[inline]
            pub fn add_fragments(
                &mut self,
                fragments: flatbuffers::WIPOffset<
                    flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<KnownTechFragment<'b>>>,
                >,
            ) {
                self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                    PendingMigration::VT_FRAGMENTS,
                    fragments,
                );
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
            ) -> PendingMigrationBuilder<'a, 'b, A> {
                let start = _fbb.start_table();
                PendingMigrationBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<PendingMigration<'a>> {
                let o = self.fbb_.end_table(self.start_);
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        impl core::fmt::Debug for PendingMigration<'_> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                let mut ds = f.debug_struct("PendingMigration");
                ds.field("destination", &self.destination());
                ds.field("eta", &self.eta());
                ds.field("fragments", &self.fragments());
                ds.finish()
            }
        }
        pub enum PowerNodeStateOffset {}
        #[derive(Copy, Clone, PartialEq)]

        pub struct PowerNodeState<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for PowerNodeState<'a> {
            type Inner = PowerNodeState<'a>;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: unsafe { flatbuffers::Table::new(buf, loc) },
                }
            }
        }

        impl<'a> PowerNodeState<'a> {
            pub const VT_ENTITY: flatbuffers::VOffsetT = 4;
            pub const VT_GENERATION: flatbuffers::VOffsetT = 6;
            pub const VT_DEMAND: flatbuffers::VOffsetT = 8;
            pub const VT_EFFICIENCY: flatbuffers::VOffsetT = 10;

            #[inline]
            pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                PowerNodeState { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<
                'bldr: 'args,
                'args: 'mut_bldr,
                'mut_bldr,
                A: flatbuffers::Allocator + 'bldr,
            >(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
                args: &'args PowerNodeStateArgs,
            ) -> flatbuffers::WIPOffset<PowerNodeState<'bldr>> {
                let mut builder = PowerNodeStateBuilder::new(_fbb);
                builder.add_efficiency(args.efficiency);
                builder.add_demand(args.demand);
                builder.add_generation(args.generation);
                builder.add_entity(args.entity);
                builder.finish()
            }

            #[inline]
            pub fn entity(&self) -> u64 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<u64>(PowerNodeState::VT_ENTITY, Some(0))
                        .unwrap()
                }
            }
            #[inline]
            pub fn generation(&self) -> i64 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<i64>(PowerNodeState::VT_GENERATION, Some(0))
                        .unwrap()
                }
            }
            #[inline]
            pub fn demand(&self) -> i64 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<i64>(PowerNodeState::VT_DEMAND, Some(0))
                        .unwrap()
                }
            }
            #[inline]
            pub fn efficiency(&self) -> i64 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<i64>(PowerNodeState::VT_EFFICIENCY, Some(0))
                        .unwrap()
                }
            }
        }

        impl flatbuffers::Verifiable for PowerNodeState<'_> {
            #[inline]
            fn run_verifier(
                v: &mut flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                v.visit_table(pos)?
                    .visit_field::<u64>("entity", Self::VT_ENTITY, false)?
                    .visit_field::<i64>("generation", Self::VT_GENERATION, false)?
                    .visit_field::<i64>("demand", Self::VT_DEMAND, false)?
                    .visit_field::<i64>("efficiency", Self::VT_EFFICIENCY, false)?
                    .finish();
                Ok(())
            }
        }
        pub struct PowerNodeStateArgs {
            pub entity: u64,
            pub generation: i64,
            pub demand: i64,
            pub efficiency: i64,
        }
        impl<'a> Default for PowerNodeStateArgs {
            #[inline]
            fn default() -> Self {
                PowerNodeStateArgs {
                    entity: 0,
                    generation: 0,
                    demand: 0,
                    efficiency: 0,
                }
            }
        }

        pub struct PowerNodeStateBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> PowerNodeStateBuilder<'a, 'b, A> {
            #[inline]
            pub fn add_entity(&mut self, entity: u64) {
                self.fbb_
                    .push_slot::<u64>(PowerNodeState::VT_ENTITY, entity, 0);
            }
            #[inline]
            pub fn add_generation(&mut self, generation: i64) {
                self.fbb_
                    .push_slot::<i64>(PowerNodeState::VT_GENERATION, generation, 0);
            }
            #[inline]
            pub fn add_demand(&mut self, demand: i64) {
                self.fbb_
                    .push_slot::<i64>(PowerNodeState::VT_DEMAND, demand, 0);
            }
            #[inline]
            pub fn add_efficiency(&mut self, efficiency: i64) {
                self.fbb_
                    .push_slot::<i64>(PowerNodeState::VT_EFFICIENCY, efficiency, 0);
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
            ) -> PowerNodeStateBuilder<'a, 'b, A> {
                let start = _fbb.start_table();
                PowerNodeStateBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<PowerNodeState<'a>> {
                let o = self.fbb_.end_table(self.start_);
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        impl core::fmt::Debug for PowerNodeState<'_> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                let mut ds = f.debug_struct("PowerNodeState");
                ds.field("entity", &self.entity());
                ds.field("generation", &self.generation());
                ds.field("demand", &self.demand());
                ds.field("efficiency", &self.efficiency());
                ds.finish()
            }
        }
        pub enum CorruptionEntryOffset {}
        #[derive(Copy, Clone, PartialEq)]

        pub struct CorruptionEntry<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for CorruptionEntry<'a> {
            type Inner = CorruptionEntry<'a>;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: unsafe { flatbuffers::Table::new(buf, loc) },
                }
            }
        }

        impl<'a> CorruptionEntry<'a> {
            pub const VT_SUBSYSTEM: flatbuffers::VOffsetT = 4;
            pub const VT_INTENSITY: flatbuffers::VOffsetT = 6;
            pub const VT_INCIDENTID: flatbuffers::VOffsetT = 8;
            pub const VT_EXPOSURETIMER: flatbuffers::VOffsetT = 10;
            pub const VT_RESTITUTIONWINDOW: flatbuffers::VOffsetT = 12;
            pub const VT_LASTUPDATETICK: flatbuffers::VOffsetT = 14;

            #[inline]
            pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                CorruptionEntry { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<
                'bldr: 'args,
                'args: 'mut_bldr,
                'mut_bldr,
                A: flatbuffers::Allocator + 'bldr,
            >(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
                args: &'args CorruptionEntryArgs,
            ) -> flatbuffers::WIPOffset<CorruptionEntry<'bldr>> {
                let mut builder = CorruptionEntryBuilder::new(_fbb);
                builder.add_lastUpdateTick(args.lastUpdateTick);
                builder.add_incidentId(args.incidentId);
                builder.add_intensity(args.intensity);
                builder.add_restitutionWindow(args.restitutionWindow);
                builder.add_exposureTimer(args.exposureTimer);
                builder.add_subsystem(args.subsystem);
                builder.finish()
            }

            #[inline]
            pub fn subsystem(&self) -> CorruptionSubsystem {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<CorruptionSubsystem>(
                            CorruptionEntry::VT_SUBSYSTEM,
                            Some(CorruptionSubsystem::Logistics),
                        )
                        .unwrap()
                }
            }
            #[inline]
            pub fn intensity(&self) -> i64 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<i64>(CorruptionEntry::VT_INTENSITY, Some(0))
                        .unwrap()
                }
            }
            #[inline]
            pub fn incidentId(&self) -> u64 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<u64>(CorruptionEntry::VT_INCIDENTID, Some(0))
                        .unwrap()
                }
            }
            #[inline]
            pub fn exposureTimer(&self) -> u16 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<u16>(CorruptionEntry::VT_EXPOSURETIMER, Some(0))
                        .unwrap()
                }
            }
            #[inline]
            pub fn restitutionWindow(&self) -> u16 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<u16>(CorruptionEntry::VT_RESTITUTIONWINDOW, Some(0))
                        .unwrap()
                }
            }
            #[inline]
            pub fn lastUpdateTick(&self) -> u64 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<u64>(CorruptionEntry::VT_LASTUPDATETICK, Some(0))
                        .unwrap()
                }
            }
        }

        impl flatbuffers::Verifiable for CorruptionEntry<'_> {
            #[inline]
            fn run_verifier(
                v: &mut flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                v.visit_table(pos)?
                    .visit_field::<CorruptionSubsystem>("subsystem", Self::VT_SUBSYSTEM, false)?
                    .visit_field::<i64>("intensity", Self::VT_INTENSITY, false)?
                    .visit_field::<u64>("incidentId", Self::VT_INCIDENTID, false)?
                    .visit_field::<u16>("exposureTimer", Self::VT_EXPOSURETIMER, false)?
                    .visit_field::<u16>("restitutionWindow", Self::VT_RESTITUTIONWINDOW, false)?
                    .visit_field::<u64>("lastUpdateTick", Self::VT_LASTUPDATETICK, false)?
                    .finish();
                Ok(())
            }
        }
        pub struct CorruptionEntryArgs {
            pub subsystem: CorruptionSubsystem,
            pub intensity: i64,
            pub incidentId: u64,
            pub exposureTimer: u16,
            pub restitutionWindow: u16,
            pub lastUpdateTick: u64,
        }
        impl<'a> Default for CorruptionEntryArgs {
            #[inline]
            fn default() -> Self {
                CorruptionEntryArgs {
                    subsystem: CorruptionSubsystem::Logistics,
                    intensity: 0,
                    incidentId: 0,
                    exposureTimer: 0,
                    restitutionWindow: 0,
                    lastUpdateTick: 0,
                }
            }
        }

        pub struct CorruptionEntryBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> CorruptionEntryBuilder<'a, 'b, A> {
            #[inline]
            pub fn add_subsystem(&mut self, subsystem: CorruptionSubsystem) {
                self.fbb_.push_slot::<CorruptionSubsystem>(
                    CorruptionEntry::VT_SUBSYSTEM,
                    subsystem,
                    CorruptionSubsystem::Logistics,
                );
            }
            #[inline]
            pub fn add_intensity(&mut self, intensity: i64) {
                self.fbb_
                    .push_slot::<i64>(CorruptionEntry::VT_INTENSITY, intensity, 0);
            }
            #[inline]
            pub fn add_incidentId(&mut self, incidentId: u64) {
                self.fbb_
                    .push_slot::<u64>(CorruptionEntry::VT_INCIDENTID, incidentId, 0);
            }
            #[inline]
            pub fn add_exposureTimer(&mut self, exposureTimer: u16) {
                self.fbb_
                    .push_slot::<u16>(CorruptionEntry::VT_EXPOSURETIMER, exposureTimer, 0);
            }
            #[inline]
            pub fn add_restitutionWindow(&mut self, restitutionWindow: u16) {
                self.fbb_.push_slot::<u16>(
                    CorruptionEntry::VT_RESTITUTIONWINDOW,
                    restitutionWindow,
                    0,
                );
            }
            #[inline]
            pub fn add_lastUpdateTick(&mut self, lastUpdateTick: u64) {
                self.fbb_
                    .push_slot::<u64>(CorruptionEntry::VT_LASTUPDATETICK, lastUpdateTick, 0);
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
            ) -> CorruptionEntryBuilder<'a, 'b, A> {
                let start = _fbb.start_table();
                CorruptionEntryBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<CorruptionEntry<'a>> {
                let o = self.fbb_.end_table(self.start_);
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        impl core::fmt::Debug for CorruptionEntry<'_> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                let mut ds = f.debug_struct("CorruptionEntry");
                ds.field("subsystem", &self.subsystem());
                ds.field("intensity", &self.intensity());
                ds.field("incidentId", &self.incidentId());
                ds.field("exposureTimer", &self.exposureTimer());
                ds.field("restitutionWindow", &self.restitutionWindow());
                ds.field("lastUpdateTick", &self.lastUpdateTick());
                ds.finish()
            }
        }
        pub enum CorruptionLedgerOffset {}
        #[derive(Copy, Clone, PartialEq)]

        pub struct CorruptionLedger<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for CorruptionLedger<'a> {
            type Inner = CorruptionLedger<'a>;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: unsafe { flatbuffers::Table::new(buf, loc) },
                }
            }
        }

        impl<'a> CorruptionLedger<'a> {
            pub const VT_ENTRIES: flatbuffers::VOffsetT = 4;
            pub const VT_REPUTATIONMODIFIER: flatbuffers::VOffsetT = 6;
            pub const VT_AUDITCAPACITY: flatbuffers::VOffsetT = 8;

            #[inline]
            pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                CorruptionLedger { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<
                'bldr: 'args,
                'args: 'mut_bldr,
                'mut_bldr,
                A: flatbuffers::Allocator + 'bldr,
            >(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
                args: &'args CorruptionLedgerArgs<'args>,
            ) -> flatbuffers::WIPOffset<CorruptionLedger<'bldr>> {
                let mut builder = CorruptionLedgerBuilder::new(_fbb);
                builder.add_reputationModifier(args.reputationModifier);
                if let Some(x) = args.entries {
                    builder.add_entries(x);
                }
                builder.add_auditCapacity(args.auditCapacity);
                builder.finish()
            }

            #[inline]
            pub fn entries(
                &self,
            ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<CorruptionEntry<'a>>>>
            {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab.get::<flatbuffers::ForwardsUOffset<
                        flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<CorruptionEntry>>,
                    >>(CorruptionLedger::VT_ENTRIES, None)
                }
            }
            #[inline]
            pub fn reputationModifier(&self) -> i64 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<i64>(CorruptionLedger::VT_REPUTATIONMODIFIER, Some(0))
                        .unwrap()
                }
            }
            #[inline]
            pub fn auditCapacity(&self) -> u16 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<u16>(CorruptionLedger::VT_AUDITCAPACITY, Some(0))
                        .unwrap()
                }
            }
        }

        impl flatbuffers::Verifiable for CorruptionLedger<'_> {
            #[inline]
            fn run_verifier(
                v: &mut flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                v.visit_table(pos)?
                    .visit_field::<flatbuffers::ForwardsUOffset<
                        flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<CorruptionEntry>>,
                    >>("entries", Self::VT_ENTRIES, false)?
                    .visit_field::<i64>("reputationModifier", Self::VT_REPUTATIONMODIFIER, false)?
                    .visit_field::<u16>("auditCapacity", Self::VT_AUDITCAPACITY, false)?
                    .finish();
                Ok(())
            }
        }
        pub struct CorruptionLedgerArgs<'a> {
            pub entries: Option<
                flatbuffers::WIPOffset<
                    flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<CorruptionEntry<'a>>>,
                >,
            >,
            pub reputationModifier: i64,
            pub auditCapacity: u16,
        }
        impl<'a> Default for CorruptionLedgerArgs<'a> {
            #[inline]
            fn default() -> Self {
                CorruptionLedgerArgs {
                    entries: None,
                    reputationModifier: 0,
                    auditCapacity: 0,
                }
            }
        }

        pub struct CorruptionLedgerBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> CorruptionLedgerBuilder<'a, 'b, A> {
            #[inline]
            pub fn add_entries(
                &mut self,
                entries: flatbuffers::WIPOffset<
                    flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<CorruptionEntry<'b>>>,
                >,
            ) {
                self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                    CorruptionLedger::VT_ENTRIES,
                    entries,
                );
            }
            #[inline]
            pub fn add_reputationModifier(&mut self, reputationModifier: i64) {
                self.fbb_.push_slot::<i64>(
                    CorruptionLedger::VT_REPUTATIONMODIFIER,
                    reputationModifier,
                    0,
                );
            }
            #[inline]
            pub fn add_auditCapacity(&mut self, auditCapacity: u16) {
                self.fbb_
                    .push_slot::<u16>(CorruptionLedger::VT_AUDITCAPACITY, auditCapacity, 0);
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
            ) -> CorruptionLedgerBuilder<'a, 'b, A> {
                let start = _fbb.start_table();
                CorruptionLedgerBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<CorruptionLedger<'a>> {
                let o = self.fbb_.end_table(self.start_);
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        impl core::fmt::Debug for CorruptionLedger<'_> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                let mut ds = f.debug_struct("CorruptionLedger");
                ds.field("entries", &self.entries());
                ds.field("reputationModifier", &self.reputationModifier());
                ds.field("auditCapacity", &self.auditCapacity());
                ds.finish()
            }
        }
        pub enum AxisBiasStateOffset {}
        #[derive(Copy, Clone, PartialEq)]

        pub struct AxisBiasState<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for AxisBiasState<'a> {
            type Inner = AxisBiasState<'a>;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: unsafe { flatbuffers::Table::new(buf, loc) },
                }
            }
        }

        impl<'a> AxisBiasState<'a> {
            pub const VT_KNOWLEDGE: flatbuffers::VOffsetT = 4;
            pub const VT_TRUST: flatbuffers::VOffsetT = 6;
            pub const VT_EQUITY: flatbuffers::VOffsetT = 8;
            pub const VT_AGENCY: flatbuffers::VOffsetT = 10;

            #[inline]
            pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                AxisBiasState { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<
                'bldr: 'args,
                'args: 'mut_bldr,
                'mut_bldr,
                A: flatbuffers::Allocator + 'bldr,
            >(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
                args: &'args AxisBiasStateArgs,
            ) -> flatbuffers::WIPOffset<AxisBiasState<'bldr>> {
                let mut builder = AxisBiasStateBuilder::new(_fbb);
                builder.add_agency(args.agency);
                builder.add_equity(args.equity);
                builder.add_trust(args.trust);
                builder.add_knowledge(args.knowledge);
                builder.finish()
            }

            #[inline]
            pub fn knowledge(&self) -> i64 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<i64>(AxisBiasState::VT_KNOWLEDGE, Some(0))
                        .unwrap()
                }
            }
            #[inline]
            pub fn trust(&self) -> i64 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<i64>(AxisBiasState::VT_TRUST, Some(0))
                        .unwrap()
                }
            }
            #[inline]
            pub fn equity(&self) -> i64 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<i64>(AxisBiasState::VT_EQUITY, Some(0))
                        .unwrap()
                }
            }
            #[inline]
            pub fn agency(&self) -> i64 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<i64>(AxisBiasState::VT_AGENCY, Some(0))
                        .unwrap()
                }
            }
        }

        impl flatbuffers::Verifiable for AxisBiasState<'_> {
            #[inline]
            fn run_verifier(
                v: &mut flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                v.visit_table(pos)?
                    .visit_field::<i64>("knowledge", Self::VT_KNOWLEDGE, false)?
                    .visit_field::<i64>("trust", Self::VT_TRUST, false)?
                    .visit_field::<i64>("equity", Self::VT_EQUITY, false)?
                    .visit_field::<i64>("agency", Self::VT_AGENCY, false)?
                    .finish();
                Ok(())
            }
        }
        pub struct AxisBiasStateArgs {
            pub knowledge: i64,
            pub trust: i64,
            pub equity: i64,
            pub agency: i64,
        }
        impl<'a> Default for AxisBiasStateArgs {
            #[inline]
            fn default() -> Self {
                AxisBiasStateArgs {
                    knowledge: 0,
                    trust: 0,
                    equity: 0,
                    agency: 0,
                }
            }
        }

        pub struct AxisBiasStateBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> AxisBiasStateBuilder<'a, 'b, A> {
            #[inline]
            pub fn add_knowledge(&mut self, knowledge: i64) {
                self.fbb_
                    .push_slot::<i64>(AxisBiasState::VT_KNOWLEDGE, knowledge, 0);
            }
            #[inline]
            pub fn add_trust(&mut self, trust: i64) {
                self.fbb_
                    .push_slot::<i64>(AxisBiasState::VT_TRUST, trust, 0);
            }
            #[inline]
            pub fn add_equity(&mut self, equity: i64) {
                self.fbb_
                    .push_slot::<i64>(AxisBiasState::VT_EQUITY, equity, 0);
            }
            #[inline]
            pub fn add_agency(&mut self, agency: i64) {
                self.fbb_
                    .push_slot::<i64>(AxisBiasState::VT_AGENCY, agency, 0);
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
            ) -> AxisBiasStateBuilder<'a, 'b, A> {
                let start = _fbb.start_table();
                AxisBiasStateBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<AxisBiasState<'a>> {
                let o = self.fbb_.end_table(self.start_);
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        impl core::fmt::Debug for AxisBiasState<'_> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                let mut ds = f.debug_struct("AxisBiasState");
                ds.field("knowledge", &self.knowledge());
                ds.field("trust", &self.trust());
                ds.field("equity", &self.equity());
                ds.field("agency", &self.agency());
                ds.finish()
            }
        }
        pub enum SentimentDriverStateOffset {}
        #[derive(Copy, Clone, PartialEq)]

        pub struct SentimentDriverState<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for SentimentDriverState<'a> {
            type Inner = SentimentDriverState<'a>;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: unsafe { flatbuffers::Table::new(buf, loc) },
                }
            }
        }

        impl<'a> SentimentDriverState<'a> {
            pub const VT_CATEGORY: flatbuffers::VOffsetT = 4;
            pub const VT_LABEL: flatbuffers::VOffsetT = 6;
            pub const VT_VALUE: flatbuffers::VOffsetT = 8;
            pub const VT_WEIGHT: flatbuffers::VOffsetT = 10;

            #[inline]
            pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                SentimentDriverState { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<
                'bldr: 'args,
                'args: 'mut_bldr,
                'mut_bldr,
                A: flatbuffers::Allocator + 'bldr,
            >(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
                args: &'args SentimentDriverStateArgs<'args>,
            ) -> flatbuffers::WIPOffset<SentimentDriverState<'bldr>> {
                let mut builder = SentimentDriverStateBuilder::new(_fbb);
                builder.add_weight(args.weight);
                builder.add_value(args.value);
                if let Some(x) = args.label {
                    builder.add_label(x);
                }
                builder.add_category(args.category);
                builder.finish()
            }

            #[inline]
            pub fn category(&self) -> SentimentDriverCategory {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<SentimentDriverCategory>(
                            SentimentDriverState::VT_CATEGORY,
                            Some(SentimentDriverCategory::Policy),
                        )
                        .unwrap()
                }
            }
            #[inline]
            pub fn label(&self) -> Option<&'a str> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                        SentimentDriverState::VT_LABEL,
                        None,
                    )
                }
            }
            #[inline]
            pub fn value(&self) -> i64 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<i64>(SentimentDriverState::VT_VALUE, Some(0))
                        .unwrap()
                }
            }
            #[inline]
            pub fn weight(&self) -> i64 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<i64>(SentimentDriverState::VT_WEIGHT, Some(0))
                        .unwrap()
                }
            }
        }

        impl flatbuffers::Verifiable for SentimentDriverState<'_> {
            #[inline]
            fn run_verifier(
                v: &mut flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                v.visit_table(pos)?
                    .visit_field::<SentimentDriverCategory>("category", Self::VT_CATEGORY, false)?
                    .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                        "label",
                        Self::VT_LABEL,
                        false,
                    )?
                    .visit_field::<i64>("value", Self::VT_VALUE, false)?
                    .visit_field::<i64>("weight", Self::VT_WEIGHT, false)?
                    .finish();
                Ok(())
            }
        }
        pub struct SentimentDriverStateArgs<'a> {
            pub category: SentimentDriverCategory,
            pub label: Option<flatbuffers::WIPOffset<&'a str>>,
            pub value: i64,
            pub weight: i64,
        }
        impl<'a> Default for SentimentDriverStateArgs<'a> {
            #[inline]
            fn default() -> Self {
                SentimentDriverStateArgs {
                    category: SentimentDriverCategory::Policy,
                    label: None,
                    value: 0,
                    weight: 0,
                }
            }
        }

        pub struct SentimentDriverStateBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> SentimentDriverStateBuilder<'a, 'b, A> {
            #[inline]
            pub fn add_category(&mut self, category: SentimentDriverCategory) {
                self.fbb_.push_slot::<SentimentDriverCategory>(
                    SentimentDriverState::VT_CATEGORY,
                    category,
                    SentimentDriverCategory::Policy,
                );
            }
            #[inline]
            pub fn add_label(&mut self, label: flatbuffers::WIPOffset<&'b str>) {
                self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                    SentimentDriverState::VT_LABEL,
                    label,
                );
            }
            #[inline]
            pub fn add_value(&mut self, value: i64) {
                self.fbb_
                    .push_slot::<i64>(SentimentDriverState::VT_VALUE, value, 0);
            }
            #[inline]
            pub fn add_weight(&mut self, weight: i64) {
                self.fbb_
                    .push_slot::<i64>(SentimentDriverState::VT_WEIGHT, weight, 0);
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
            ) -> SentimentDriverStateBuilder<'a, 'b, A> {
                let start = _fbb.start_table();
                SentimentDriverStateBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<SentimentDriverState<'a>> {
                let o = self.fbb_.end_table(self.start_);
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        impl core::fmt::Debug for SentimentDriverState<'_> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                let mut ds = f.debug_struct("SentimentDriverState");
                ds.field("category", &self.category());
                ds.field("label", &self.label());
                ds.field("value", &self.value());
                ds.field("weight", &self.weight());
                ds.finish()
            }
        }
        pub enum SentimentAxisTelemetryOffset {}
        #[derive(Copy, Clone, PartialEq)]

        pub struct SentimentAxisTelemetry<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for SentimentAxisTelemetry<'a> {
            type Inner = SentimentAxisTelemetry<'a>;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: unsafe { flatbuffers::Table::new(buf, loc) },
                }
            }
        }

        impl<'a> SentimentAxisTelemetry<'a> {
            pub const VT_POLICY: flatbuffers::VOffsetT = 4;
            pub const VT_INCIDENTS: flatbuffers::VOffsetT = 6;
            pub const VT_INFLUENCERS: flatbuffers::VOffsetT = 8;
            pub const VT_TOTAL: flatbuffers::VOffsetT = 10;
            pub const VT_DRIVERS: flatbuffers::VOffsetT = 12;

            #[inline]
            pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                SentimentAxisTelemetry { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<
                'bldr: 'args,
                'args: 'mut_bldr,
                'mut_bldr,
                A: flatbuffers::Allocator + 'bldr,
            >(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
                args: &'args SentimentAxisTelemetryArgs<'args>,
            ) -> flatbuffers::WIPOffset<SentimentAxisTelemetry<'bldr>> {
                let mut builder = SentimentAxisTelemetryBuilder::new(_fbb);
                builder.add_total(args.total);
                builder.add_influencers(args.influencers);
                builder.add_incidents(args.incidents);
                builder.add_policy(args.policy);
                if let Some(x) = args.drivers {
                    builder.add_drivers(x);
                }
                builder.finish()
            }

            #[inline]
            pub fn policy(&self) -> i64 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<i64>(SentimentAxisTelemetry::VT_POLICY, Some(0))
                        .unwrap()
                }
            }
            #[inline]
            pub fn incidents(&self) -> i64 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<i64>(SentimentAxisTelemetry::VT_INCIDENTS, Some(0))
                        .unwrap()
                }
            }
            #[inline]
            pub fn influencers(&self) -> i64 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<i64>(SentimentAxisTelemetry::VT_INFLUENCERS, Some(0))
                        .unwrap()
                }
            }
            #[inline]
            pub fn total(&self) -> i64 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<i64>(SentimentAxisTelemetry::VT_TOTAL, Some(0))
                        .unwrap()
                }
            }
            #[inline]
            pub fn drivers(
                &self,
            ) -> Option<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<SentimentDriverState<'a>>>,
            > {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab.get::<flatbuffers::ForwardsUOffset<
                        flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<SentimentDriverState>>,
                    >>(SentimentAxisTelemetry::VT_DRIVERS, None)
                }
            }
        }

        impl flatbuffers::Verifiable for SentimentAxisTelemetry<'_> {
            #[inline]
            fn run_verifier(
                v: &mut flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                v.visit_table(pos)?
                    .visit_field::<i64>("policy", Self::VT_POLICY, false)?
                    .visit_field::<i64>("incidents", Self::VT_INCIDENTS, false)?
                    .visit_field::<i64>("influencers", Self::VT_INFLUENCERS, false)?
                    .visit_field::<i64>("total", Self::VT_TOTAL, false)?
                    .visit_field::<flatbuffers::ForwardsUOffset<
                        flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<SentimentDriverState>>,
                    >>("drivers", Self::VT_DRIVERS, false)?
                    .finish();
                Ok(())
            }
        }
        pub struct SentimentAxisTelemetryArgs<'a> {
            pub policy: i64,
            pub incidents: i64,
            pub influencers: i64,
            pub total: i64,
            pub drivers: Option<
                flatbuffers::WIPOffset<
                    flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<SentimentDriverState<'a>>>,
                >,
            >,
        }
        impl<'a> Default for SentimentAxisTelemetryArgs<'a> {
            #[inline]
            fn default() -> Self {
                SentimentAxisTelemetryArgs {
                    policy: 0,
                    incidents: 0,
                    influencers: 0,
                    total: 0,
                    drivers: None,
                }
            }
        }

        pub struct SentimentAxisTelemetryBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> SentimentAxisTelemetryBuilder<'a, 'b, A> {
            #[inline]
            pub fn add_policy(&mut self, policy: i64) {
                self.fbb_
                    .push_slot::<i64>(SentimentAxisTelemetry::VT_POLICY, policy, 0);
            }
            #[inline]
            pub fn add_incidents(&mut self, incidents: i64) {
                self.fbb_
                    .push_slot::<i64>(SentimentAxisTelemetry::VT_INCIDENTS, incidents, 0);
            }
            #[inline]
            pub fn add_influencers(&mut self, influencers: i64) {
                self.fbb_
                    .push_slot::<i64>(SentimentAxisTelemetry::VT_INFLUENCERS, influencers, 0);
            }
            #[inline]
            pub fn add_total(&mut self, total: i64) {
                self.fbb_
                    .push_slot::<i64>(SentimentAxisTelemetry::VT_TOTAL, total, 0);
            }
            #[inline]
            pub fn add_drivers(
                &mut self,
                drivers: flatbuffers::WIPOffset<
                    flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<SentimentDriverState<'b>>>,
                >,
            ) {
                self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                    SentimentAxisTelemetry::VT_DRIVERS,
                    drivers,
                );
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
            ) -> SentimentAxisTelemetryBuilder<'a, 'b, A> {
                let start = _fbb.start_table();
                SentimentAxisTelemetryBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<SentimentAxisTelemetry<'a>> {
                let o = self.fbb_.end_table(self.start_);
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        impl core::fmt::Debug for SentimentAxisTelemetry<'_> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                let mut ds = f.debug_struct("SentimentAxisTelemetry");
                ds.field("policy", &self.policy());
                ds.field("incidents", &self.incidents());
                ds.field("influencers", &self.influencers());
                ds.field("total", &self.total());
                ds.field("drivers", &self.drivers());
                ds.finish()
            }
        }
        pub enum SentimentTelemetryStateOffset {}
        #[derive(Copy, Clone, PartialEq)]

        pub struct SentimentTelemetryState<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for SentimentTelemetryState<'a> {
            type Inner = SentimentTelemetryState<'a>;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: unsafe { flatbuffers::Table::new(buf, loc) },
                }
            }
        }

        impl<'a> SentimentTelemetryState<'a> {
            pub const VT_KNOWLEDGE: flatbuffers::VOffsetT = 4;
            pub const VT_TRUST: flatbuffers::VOffsetT = 6;
            pub const VT_EQUITY: flatbuffers::VOffsetT = 8;
            pub const VT_AGENCY: flatbuffers::VOffsetT = 10;

            #[inline]
            pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                SentimentTelemetryState { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<
                'bldr: 'args,
                'args: 'mut_bldr,
                'mut_bldr,
                A: flatbuffers::Allocator + 'bldr,
            >(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
                args: &'args SentimentTelemetryStateArgs<'args>,
            ) -> flatbuffers::WIPOffset<SentimentTelemetryState<'bldr>> {
                let mut builder = SentimentTelemetryStateBuilder::new(_fbb);
                if let Some(x) = args.agency {
                    builder.add_agency(x);
                }
                if let Some(x) = args.equity {
                    builder.add_equity(x);
                }
                if let Some(x) = args.trust {
                    builder.add_trust(x);
                }
                if let Some(x) = args.knowledge {
                    builder.add_knowledge(x);
                }
                builder.finish()
            }

            #[inline]
            pub fn knowledge(&self) -> Option<SentimentAxisTelemetry<'a>> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<flatbuffers::ForwardsUOffset<SentimentAxisTelemetry>>(
                            SentimentTelemetryState::VT_KNOWLEDGE,
                            None,
                        )
                }
            }
            #[inline]
            pub fn trust(&self) -> Option<SentimentAxisTelemetry<'a>> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<flatbuffers::ForwardsUOffset<SentimentAxisTelemetry>>(
                            SentimentTelemetryState::VT_TRUST,
                            None,
                        )
                }
            }
            #[inline]
            pub fn equity(&self) -> Option<SentimentAxisTelemetry<'a>> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<flatbuffers::ForwardsUOffset<SentimentAxisTelemetry>>(
                            SentimentTelemetryState::VT_EQUITY,
                            None,
                        )
                }
            }
            #[inline]
            pub fn agency(&self) -> Option<SentimentAxisTelemetry<'a>> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<flatbuffers::ForwardsUOffset<SentimentAxisTelemetry>>(
                            SentimentTelemetryState::VT_AGENCY,
                            None,
                        )
                }
            }
        }

        impl flatbuffers::Verifiable for SentimentTelemetryState<'_> {
            #[inline]
            fn run_verifier(
                v: &mut flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                v.visit_table(pos)?
                    .visit_field::<flatbuffers::ForwardsUOffset<SentimentAxisTelemetry>>(
                        "knowledge",
                        Self::VT_KNOWLEDGE,
                        false,
                    )?
                    .visit_field::<flatbuffers::ForwardsUOffset<SentimentAxisTelemetry>>(
                        "trust",
                        Self::VT_TRUST,
                        false,
                    )?
                    .visit_field::<flatbuffers::ForwardsUOffset<SentimentAxisTelemetry>>(
                        "equity",
                        Self::VT_EQUITY,
                        false,
                    )?
                    .visit_field::<flatbuffers::ForwardsUOffset<SentimentAxisTelemetry>>(
                        "agency",
                        Self::VT_AGENCY,
                        false,
                    )?
                    .finish();
                Ok(())
            }
        }
        pub struct SentimentTelemetryStateArgs<'a> {
            pub knowledge: Option<flatbuffers::WIPOffset<SentimentAxisTelemetry<'a>>>,
            pub trust: Option<flatbuffers::WIPOffset<SentimentAxisTelemetry<'a>>>,
            pub equity: Option<flatbuffers::WIPOffset<SentimentAxisTelemetry<'a>>>,
            pub agency: Option<flatbuffers::WIPOffset<SentimentAxisTelemetry<'a>>>,
        }
        impl<'a> Default for SentimentTelemetryStateArgs<'a> {
            #[inline]
            fn default() -> Self {
                SentimentTelemetryStateArgs {
                    knowledge: None,
                    trust: None,
                    equity: None,
                    agency: None,
                }
            }
        }

        pub struct SentimentTelemetryStateBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> SentimentTelemetryStateBuilder<'a, 'b, A> {
            #[inline]
            pub fn add_knowledge(
                &mut self,
                knowledge: flatbuffers::WIPOffset<SentimentAxisTelemetry<'b>>,
            ) {
                self.fbb_
                    .push_slot_always::<flatbuffers::WIPOffset<SentimentAxisTelemetry>>(
                        SentimentTelemetryState::VT_KNOWLEDGE,
                        knowledge,
                    );
            }
            #[inline]
            pub fn add_trust(&mut self, trust: flatbuffers::WIPOffset<SentimentAxisTelemetry<'b>>) {
                self.fbb_
                    .push_slot_always::<flatbuffers::WIPOffset<SentimentAxisTelemetry>>(
                        SentimentTelemetryState::VT_TRUST,
                        trust,
                    );
            }
            #[inline]
            pub fn add_equity(
                &mut self,
                equity: flatbuffers::WIPOffset<SentimentAxisTelemetry<'b>>,
            ) {
                self.fbb_
                    .push_slot_always::<flatbuffers::WIPOffset<SentimentAxisTelemetry>>(
                        SentimentTelemetryState::VT_EQUITY,
                        equity,
                    );
            }
            #[inline]
            pub fn add_agency(
                &mut self,
                agency: flatbuffers::WIPOffset<SentimentAxisTelemetry<'b>>,
            ) {
                self.fbb_
                    .push_slot_always::<flatbuffers::WIPOffset<SentimentAxisTelemetry>>(
                        SentimentTelemetryState::VT_AGENCY,
                        agency,
                    );
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
            ) -> SentimentTelemetryStateBuilder<'a, 'b, A> {
                let start = _fbb.start_table();
                SentimentTelemetryStateBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<SentimentTelemetryState<'a>> {
                let o = self.fbb_.end_table(self.start_);
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        impl core::fmt::Debug for SentimentTelemetryState<'_> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                let mut ds = f.debug_struct("SentimentTelemetryState");
                ds.field("knowledge", &self.knowledge());
                ds.field("trust", &self.trust());
                ds.field("equity", &self.equity());
                ds.field("agency", &self.agency());
                ds.finish()
            }
        }
        pub enum GenerationStateOffset {}
        #[derive(Copy, Clone, PartialEq)]

        pub struct GenerationState<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for GenerationState<'a> {
            type Inner = GenerationState<'a>;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: unsafe { flatbuffers::Table::new(buf, loc) },
                }
            }
        }

        impl<'a> GenerationState<'a> {
            pub const VT_ID: flatbuffers::VOffsetT = 4;
            pub const VT_NAME: flatbuffers::VOffsetT = 6;
            pub const VT_BIASKNOWLEDGE: flatbuffers::VOffsetT = 8;
            pub const VT_BIASTRUST: flatbuffers::VOffsetT = 10;
            pub const VT_BIASEQUITY: flatbuffers::VOffsetT = 12;
            pub const VT_BIASAGENCY: flatbuffers::VOffsetT = 14;

            #[inline]
            pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                GenerationState { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<
                'bldr: 'args,
                'args: 'mut_bldr,
                'mut_bldr,
                A: flatbuffers::Allocator + 'bldr,
            >(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
                args: &'args GenerationStateArgs<'args>,
            ) -> flatbuffers::WIPOffset<GenerationState<'bldr>> {
                let mut builder = GenerationStateBuilder::new(_fbb);
                builder.add_biasAgency(args.biasAgency);
                builder.add_biasEquity(args.biasEquity);
                builder.add_biasTrust(args.biasTrust);
                builder.add_biasKnowledge(args.biasKnowledge);
                if let Some(x) = args.name {
                    builder.add_name(x);
                }
                builder.add_id(args.id);
                builder.finish()
            }

            #[inline]
            pub fn id(&self) -> u16 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<u16>(GenerationState::VT_ID, Some(0))
                        .unwrap()
                }
            }
            #[inline]
            pub fn name(&self) -> Option<&'a str> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<flatbuffers::ForwardsUOffset<&str>>(GenerationState::VT_NAME, None)
                }
            }
            #[inline]
            pub fn biasKnowledge(&self) -> i64 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<i64>(GenerationState::VT_BIASKNOWLEDGE, Some(0))
                        .unwrap()
                }
            }
            #[inline]
            pub fn biasTrust(&self) -> i64 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<i64>(GenerationState::VT_BIASTRUST, Some(0))
                        .unwrap()
                }
            }
            #[inline]
            pub fn biasEquity(&self) -> i64 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<i64>(GenerationState::VT_BIASEQUITY, Some(0))
                        .unwrap()
                }
            }
            #[inline]
            pub fn biasAgency(&self) -> i64 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<i64>(GenerationState::VT_BIASAGENCY, Some(0))
                        .unwrap()
                }
            }
        }

        impl flatbuffers::Verifiable for GenerationState<'_> {
            #[inline]
            fn run_verifier(
                v: &mut flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                v.visit_table(pos)?
                    .visit_field::<u16>("id", Self::VT_ID, false)?
                    .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                        "name",
                        Self::VT_NAME,
                        false,
                    )?
                    .visit_field::<i64>("biasKnowledge", Self::VT_BIASKNOWLEDGE, false)?
                    .visit_field::<i64>("biasTrust", Self::VT_BIASTRUST, false)?
                    .visit_field::<i64>("biasEquity", Self::VT_BIASEQUITY, false)?
                    .visit_field::<i64>("biasAgency", Self::VT_BIASAGENCY, false)?
                    .finish();
                Ok(())
            }
        }
        pub struct GenerationStateArgs<'a> {
            pub id: u16,
            pub name: Option<flatbuffers::WIPOffset<&'a str>>,
            pub biasKnowledge: i64,
            pub biasTrust: i64,
            pub biasEquity: i64,
            pub biasAgency: i64,
        }
        impl<'a> Default for GenerationStateArgs<'a> {
            #[inline]
            fn default() -> Self {
                GenerationStateArgs {
                    id: 0,
                    name: None,
                    biasKnowledge: 0,
                    biasTrust: 0,
                    biasEquity: 0,
                    biasAgency: 0,
                }
            }
        }

        pub struct GenerationStateBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> GenerationStateBuilder<'a, 'b, A> {
            #[inline]
            pub fn add_id(&mut self, id: u16) {
                self.fbb_.push_slot::<u16>(GenerationState::VT_ID, id, 0);
            }
            #[inline]
            pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b str>) {
                self.fbb_
                    .push_slot_always::<flatbuffers::WIPOffset<_>>(GenerationState::VT_NAME, name);
            }
            #[inline]
            pub fn add_biasKnowledge(&mut self, biasKnowledge: i64) {
                self.fbb_
                    .push_slot::<i64>(GenerationState::VT_BIASKNOWLEDGE, biasKnowledge, 0);
            }
            #[inline]
            pub fn add_biasTrust(&mut self, biasTrust: i64) {
                self.fbb_
                    .push_slot::<i64>(GenerationState::VT_BIASTRUST, biasTrust, 0);
            }
            #[inline]
            pub fn add_biasEquity(&mut self, biasEquity: i64) {
                self.fbb_
                    .push_slot::<i64>(GenerationState::VT_BIASEQUITY, biasEquity, 0);
            }
            #[inline]
            pub fn add_biasAgency(&mut self, biasAgency: i64) {
                self.fbb_
                    .push_slot::<i64>(GenerationState::VT_BIASAGENCY, biasAgency, 0);
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
            ) -> GenerationStateBuilder<'a, 'b, A> {
                let start = _fbb.start_table();
                GenerationStateBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<GenerationState<'a>> {
                let o = self.fbb_.end_table(self.start_);
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        impl core::fmt::Debug for GenerationState<'_> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                let mut ds = f.debug_struct("GenerationState");
                ds.field("id", &self.id());
                ds.field("name", &self.name());
                ds.field("biasKnowledge", &self.biasKnowledge());
                ds.field("biasTrust", &self.biasTrust());
                ds.field("biasEquity", &self.biasEquity());
                ds.field("biasAgency", &self.biasAgency());
                ds.finish()
            }
        }
        pub enum SnapshotHeaderOffset {}
        #[derive(Copy, Clone, PartialEq)]

        pub struct SnapshotHeader<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for SnapshotHeader<'a> {
            type Inner = SnapshotHeader<'a>;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: unsafe { flatbuffers::Table::new(buf, loc) },
                }
            }
        }

        impl<'a> SnapshotHeader<'a> {
            pub const VT_TICK: flatbuffers::VOffsetT = 4;
            pub const VT_TILECOUNT: flatbuffers::VOffsetT = 6;
            pub const VT_LOGISTICSCOUNT: flatbuffers::VOffsetT = 8;
            pub const VT_TRADELINKCOUNT: flatbuffers::VOffsetT = 10;
            pub const VT_POPULATIONCOUNT: flatbuffers::VOffsetT = 12;
            pub const VT_POWERCOUNT: flatbuffers::VOffsetT = 14;
            pub const VT_INFLUENCERCOUNT: flatbuffers::VOffsetT = 16;
            pub const VT_HASH: flatbuffers::VOffsetT = 18;

            #[inline]
            pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                SnapshotHeader { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<
                'bldr: 'args,
                'args: 'mut_bldr,
                'mut_bldr,
                A: flatbuffers::Allocator + 'bldr,
            >(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
                args: &'args SnapshotHeaderArgs,
            ) -> flatbuffers::WIPOffset<SnapshotHeader<'bldr>> {
                let mut builder = SnapshotHeaderBuilder::new(_fbb);
                builder.add_hash(args.hash);
                builder.add_tick(args.tick);
                builder.add_influencerCount(args.influencerCount);
                builder.add_powerCount(args.powerCount);
                builder.add_populationCount(args.populationCount);
                builder.add_tradeLinkCount(args.tradeLinkCount);
                builder.add_logisticsCount(args.logisticsCount);
                builder.add_tileCount(args.tileCount);
                builder.finish()
            }

            #[inline]
            pub fn tick(&self) -> u64 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<u64>(SnapshotHeader::VT_TICK, Some(0))
                        .unwrap()
                }
            }
            #[inline]
            pub fn tileCount(&self) -> u32 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<u32>(SnapshotHeader::VT_TILECOUNT, Some(0))
                        .unwrap()
                }
            }
            #[inline]
            pub fn logisticsCount(&self) -> u32 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<u32>(SnapshotHeader::VT_LOGISTICSCOUNT, Some(0))
                        .unwrap()
                }
            }
            #[inline]
            pub fn tradeLinkCount(&self) -> u32 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<u32>(SnapshotHeader::VT_TRADELINKCOUNT, Some(0))
                        .unwrap()
                }
            }
            #[inline]
            pub fn populationCount(&self) -> u32 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<u32>(SnapshotHeader::VT_POPULATIONCOUNT, Some(0))
                        .unwrap()
                }
            }
            #[inline]
            pub fn powerCount(&self) -> u32 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<u32>(SnapshotHeader::VT_POWERCOUNT, Some(0))
                        .unwrap()
                }
            }
            #[inline]
            pub fn influencerCount(&self) -> u32 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<u32>(SnapshotHeader::VT_INFLUENCERCOUNT, Some(0))
                        .unwrap()
                }
            }
            #[inline]
            pub fn hash(&self) -> u64 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<u64>(SnapshotHeader::VT_HASH, Some(0))
                        .unwrap()
                }
            }
        }

        impl flatbuffers::Verifiable for SnapshotHeader<'_> {
            #[inline]
            fn run_verifier(
                v: &mut flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                v.visit_table(pos)?
                    .visit_field::<u64>("tick", Self::VT_TICK, false)?
                    .visit_field::<u32>("tileCount", Self::VT_TILECOUNT, false)?
                    .visit_field::<u32>("logisticsCount", Self::VT_LOGISTICSCOUNT, false)?
                    .visit_field::<u32>("tradeLinkCount", Self::VT_TRADELINKCOUNT, false)?
                    .visit_field::<u32>("populationCount", Self::VT_POPULATIONCOUNT, false)?
                    .visit_field::<u32>("powerCount", Self::VT_POWERCOUNT, false)?
                    .visit_field::<u32>("influencerCount", Self::VT_INFLUENCERCOUNT, false)?
                    .visit_field::<u64>("hash", Self::VT_HASH, false)?
                    .finish();
                Ok(())
            }
        }
        pub struct SnapshotHeaderArgs {
            pub tick: u64,
            pub tileCount: u32,
            pub logisticsCount: u32,
            pub tradeLinkCount: u32,
            pub populationCount: u32,
            pub powerCount: u32,
            pub influencerCount: u32,
            pub hash: u64,
        }
        impl<'a> Default for SnapshotHeaderArgs {
            #[inline]
            fn default() -> Self {
                SnapshotHeaderArgs {
                    tick: 0,
                    tileCount: 0,
                    logisticsCount: 0,
                    tradeLinkCount: 0,
                    populationCount: 0,
                    powerCount: 0,
                    influencerCount: 0,
                    hash: 0,
                }
            }
        }

        pub struct SnapshotHeaderBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> SnapshotHeaderBuilder<'a, 'b, A> {
            #[inline]
            pub fn add_tick(&mut self, tick: u64) {
                self.fbb_.push_slot::<u64>(SnapshotHeader::VT_TICK, tick, 0);
            }
            #[inline]
            pub fn add_tileCount(&mut self, tileCount: u32) {
                self.fbb_
                    .push_slot::<u32>(SnapshotHeader::VT_TILECOUNT, tileCount, 0);
            }
            #[inline]
            pub fn add_logisticsCount(&mut self, logisticsCount: u32) {
                self.fbb_
                    .push_slot::<u32>(SnapshotHeader::VT_LOGISTICSCOUNT, logisticsCount, 0);
            }
            #[inline]
            pub fn add_tradeLinkCount(&mut self, tradeLinkCount: u32) {
                self.fbb_
                    .push_slot::<u32>(SnapshotHeader::VT_TRADELINKCOUNT, tradeLinkCount, 0);
            }
            #[inline]
            pub fn add_populationCount(&mut self, populationCount: u32) {
                self.fbb_
                    .push_slot::<u32>(SnapshotHeader::VT_POPULATIONCOUNT, populationCount, 0);
            }
            #[inline]
            pub fn add_powerCount(&mut self, powerCount: u32) {
                self.fbb_
                    .push_slot::<u32>(SnapshotHeader::VT_POWERCOUNT, powerCount, 0);
            }
            #[inline]
            pub fn add_influencerCount(&mut self, influencerCount: u32) {
                self.fbb_
                    .push_slot::<u32>(SnapshotHeader::VT_INFLUENCERCOUNT, influencerCount, 0);
            }
            #[inline]
            pub fn add_hash(&mut self, hash: u64) {
                self.fbb_.push_slot::<u64>(SnapshotHeader::VT_HASH, hash, 0);
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
            ) -> SnapshotHeaderBuilder<'a, 'b, A> {
                let start = _fbb.start_table();
                SnapshotHeaderBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<SnapshotHeader<'a>> {
                let o = self.fbb_.end_table(self.start_);
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        impl core::fmt::Debug for SnapshotHeader<'_> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                let mut ds = f.debug_struct("SnapshotHeader");
                ds.field("tick", &self.tick());
                ds.field("tileCount", &self.tileCount());
                ds.field("logisticsCount", &self.logisticsCount());
                ds.field("tradeLinkCount", &self.tradeLinkCount());
                ds.field("populationCount", &self.populationCount());
                ds.field("powerCount", &self.powerCount());
                ds.field("influencerCount", &self.influencerCount());
                ds.field("hash", &self.hash());
                ds.finish()
            }
        }
        pub enum KnownTechFragmentOffset {}
        #[derive(Copy, Clone, PartialEq)]

        pub struct KnownTechFragment<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for KnownTechFragment<'a> {
            type Inner = KnownTechFragment<'a>;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: unsafe { flatbuffers::Table::new(buf, loc) },
                }
            }
        }

        impl<'a> KnownTechFragment<'a> {
            pub const VT_DISCOVERYID: flatbuffers::VOffsetT = 4;
            pub const VT_PROGRESS: flatbuffers::VOffsetT = 6;
            pub const VT_FIDELITY: flatbuffers::VOffsetT = 8;

            #[inline]
            pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                KnownTechFragment { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<
                'bldr: 'args,
                'args: 'mut_bldr,
                'mut_bldr,
                A: flatbuffers::Allocator + 'bldr,
            >(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
                args: &'args KnownTechFragmentArgs,
            ) -> flatbuffers::WIPOffset<KnownTechFragment<'bldr>> {
                let mut builder = KnownTechFragmentBuilder::new(_fbb);
                builder.add_fidelity(args.fidelity);
                builder.add_progress(args.progress);
                builder.add_discoveryId(args.discoveryId);
                builder.finish()
            }

            #[inline]
            pub fn discoveryId(&self) -> u32 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<u32>(KnownTechFragment::VT_DISCOVERYID, Some(0))
                        .unwrap()
                }
            }
            #[inline]
            pub fn progress(&self) -> i64 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<i64>(KnownTechFragment::VT_PROGRESS, Some(0))
                        .unwrap()
                }
            }
            #[inline]
            pub fn fidelity(&self) -> i64 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<i64>(KnownTechFragment::VT_FIDELITY, Some(0))
                        .unwrap()
                }
            }
        }

        impl flatbuffers::Verifiable for KnownTechFragment<'_> {
            #[inline]
            fn run_verifier(
                v: &mut flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                v.visit_table(pos)?
                    .visit_field::<u32>("discoveryId", Self::VT_DISCOVERYID, false)?
                    .visit_field::<i64>("progress", Self::VT_PROGRESS, false)?
                    .visit_field::<i64>("fidelity", Self::VT_FIDELITY, false)?
                    .finish();
                Ok(())
            }
        }
        pub struct KnownTechFragmentArgs {
            pub discoveryId: u32,
            pub progress: i64,
            pub fidelity: i64,
        }
        impl<'a> Default for KnownTechFragmentArgs {
            #[inline]
            fn default() -> Self {
                KnownTechFragmentArgs {
                    discoveryId: 0,
                    progress: 0,
                    fidelity: 0,
                }
            }
        }

        pub struct KnownTechFragmentBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> KnownTechFragmentBuilder<'a, 'b, A> {
            #[inline]
            pub fn add_discoveryId(&mut self, discoveryId: u32) {
                self.fbb_
                    .push_slot::<u32>(KnownTechFragment::VT_DISCOVERYID, discoveryId, 0);
            }
            #[inline]
            pub fn add_progress(&mut self, progress: i64) {
                self.fbb_
                    .push_slot::<i64>(KnownTechFragment::VT_PROGRESS, progress, 0);
            }
            #[inline]
            pub fn add_fidelity(&mut self, fidelity: i64) {
                self.fbb_
                    .push_slot::<i64>(KnownTechFragment::VT_FIDELITY, fidelity, 0);
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
            ) -> KnownTechFragmentBuilder<'a, 'b, A> {
                let start = _fbb.start_table();
                KnownTechFragmentBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<KnownTechFragment<'a>> {
                let o = self.fbb_.end_table(self.start_);
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        impl core::fmt::Debug for KnownTechFragment<'_> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                let mut ds = f.debug_struct("KnownTechFragment");
                ds.field("discoveryId", &self.discoveryId());
                ds.field("progress", &self.progress());
                ds.field("fidelity", &self.fidelity());
                ds.finish()
            }
        }
        pub enum TradeLinkKnowledgeOffset {}
        #[derive(Copy, Clone, PartialEq)]

        pub struct TradeLinkKnowledge<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for TradeLinkKnowledge<'a> {
            type Inner = TradeLinkKnowledge<'a>;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: unsafe { flatbuffers::Table::new(buf, loc) },
                }
            }
        }

        impl<'a> TradeLinkKnowledge<'a> {
            pub const VT_OPENNESS: flatbuffers::VOffsetT = 4;
            pub const VT_LEAKTIMER: flatbuffers::VOffsetT = 6;
            pub const VT_LASTDISCOVERY: flatbuffers::VOffsetT = 8;
            pub const VT_DECAY: flatbuffers::VOffsetT = 10;

            #[inline]
            pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                TradeLinkKnowledge { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<
                'bldr: 'args,
                'args: 'mut_bldr,
                'mut_bldr,
                A: flatbuffers::Allocator + 'bldr,
            >(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
                args: &'args TradeLinkKnowledgeArgs,
            ) -> flatbuffers::WIPOffset<TradeLinkKnowledge<'bldr>> {
                let mut builder = TradeLinkKnowledgeBuilder::new(_fbb);
                builder.add_decay(args.decay);
                builder.add_openness(args.openness);
                builder.add_lastDiscovery(args.lastDiscovery);
                builder.add_leakTimer(args.leakTimer);
                builder.finish()
            }

            #[inline]
            pub fn openness(&self) -> i64 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<i64>(TradeLinkKnowledge::VT_OPENNESS, Some(0))
                        .unwrap()
                }
            }
            #[inline]
            pub fn leakTimer(&self) -> u32 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<u32>(TradeLinkKnowledge::VT_LEAKTIMER, Some(0))
                        .unwrap()
                }
            }
            #[inline]
            pub fn lastDiscovery(&self) -> u32 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<u32>(TradeLinkKnowledge::VT_LASTDISCOVERY, Some(0))
                        .unwrap()
                }
            }
            #[inline]
            pub fn decay(&self) -> i64 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<i64>(TradeLinkKnowledge::VT_DECAY, Some(0))
                        .unwrap()
                }
            }
        }

        impl flatbuffers::Verifiable for TradeLinkKnowledge<'_> {
            #[inline]
            fn run_verifier(
                v: &mut flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                v.visit_table(pos)?
                    .visit_field::<i64>("openness", Self::VT_OPENNESS, false)?
                    .visit_field::<u32>("leakTimer", Self::VT_LEAKTIMER, false)?
                    .visit_field::<u32>("lastDiscovery", Self::VT_LASTDISCOVERY, false)?
                    .visit_field::<i64>("decay", Self::VT_DECAY, false)?
                    .finish();
                Ok(())
            }
        }
        pub struct TradeLinkKnowledgeArgs {
            pub openness: i64,
            pub leakTimer: u32,
            pub lastDiscovery: u32,
            pub decay: i64,
        }
        impl<'a> Default for TradeLinkKnowledgeArgs {
            #[inline]
            fn default() -> Self {
                TradeLinkKnowledgeArgs {
                    openness: 0,
                    leakTimer: 0,
                    lastDiscovery: 0,
                    decay: 0,
                }
            }
        }

        pub struct TradeLinkKnowledgeBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> TradeLinkKnowledgeBuilder<'a, 'b, A> {
            #[inline]
            pub fn add_openness(&mut self, openness: i64) {
                self.fbb_
                    .push_slot::<i64>(TradeLinkKnowledge::VT_OPENNESS, openness, 0);
            }
            #[inline]
            pub fn add_leakTimer(&mut self, leakTimer: u32) {
                self.fbb_
                    .push_slot::<u32>(TradeLinkKnowledge::VT_LEAKTIMER, leakTimer, 0);
            }
            #[inline]
            pub fn add_lastDiscovery(&mut self, lastDiscovery: u32) {
                self.fbb_
                    .push_slot::<u32>(TradeLinkKnowledge::VT_LASTDISCOVERY, lastDiscovery, 0);
            }
            #[inline]
            pub fn add_decay(&mut self, decay: i64) {
                self.fbb_
                    .push_slot::<i64>(TradeLinkKnowledge::VT_DECAY, decay, 0);
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
            ) -> TradeLinkKnowledgeBuilder<'a, 'b, A> {
                let start = _fbb.start_table();
                TradeLinkKnowledgeBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<TradeLinkKnowledge<'a>> {
                let o = self.fbb_.end_table(self.start_);
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        impl core::fmt::Debug for TradeLinkKnowledge<'_> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                let mut ds = f.debug_struct("TradeLinkKnowledge");
                ds.field("openness", &self.openness());
                ds.field("leakTimer", &self.leakTimer());
                ds.field("lastDiscovery", &self.lastDiscovery());
                ds.field("decay", &self.decay());
                ds.finish()
            }
        }
        pub enum TradeLinkStateOffset {}
        #[derive(Copy, Clone, PartialEq)]

        pub struct TradeLinkState<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for TradeLinkState<'a> {
            type Inner = TradeLinkState<'a>;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: unsafe { flatbuffers::Table::new(buf, loc) },
                }
            }
        }

        impl<'a> TradeLinkState<'a> {
            pub const VT_ENTITY: flatbuffers::VOffsetT = 4;
            pub const VT_FROMFACTION: flatbuffers::VOffsetT = 6;
            pub const VT_TOFACTION: flatbuffers::VOffsetT = 8;
            pub const VT_THROUGHPUT: flatbuffers::VOffsetT = 10;
            pub const VT_TARIFF: flatbuffers::VOffsetT = 12;
            pub const VT_KNOWLEDGE: flatbuffers::VOffsetT = 14;
            pub const VT_FROMTILE: flatbuffers::VOffsetT = 16;
            pub const VT_TOTILE: flatbuffers::VOffsetT = 18;
            pub const VT_PENDINGFRAGMENTS: flatbuffers::VOffsetT = 20;

            #[inline]
            pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                TradeLinkState { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<
                'bldr: 'args,
                'args: 'mut_bldr,
                'mut_bldr,
                A: flatbuffers::Allocator + 'bldr,
            >(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
                args: &'args TradeLinkStateArgs<'args>,
            ) -> flatbuffers::WIPOffset<TradeLinkState<'bldr>> {
                let mut builder = TradeLinkStateBuilder::new(_fbb);
                builder.add_toTile(args.toTile);
                builder.add_fromTile(args.fromTile);
                builder.add_tariff(args.tariff);
                builder.add_throughput(args.throughput);
                builder.add_entity(args.entity);
                if let Some(x) = args.pendingFragments {
                    builder.add_pendingFragments(x);
                }
                if let Some(x) = args.knowledge {
                    builder.add_knowledge(x);
                }
                builder.add_toFaction(args.toFaction);
                builder.add_fromFaction(args.fromFaction);
                builder.finish()
            }

            #[inline]
            pub fn entity(&self) -> u64 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<u64>(TradeLinkState::VT_ENTITY, Some(0))
                        .unwrap()
                }
            }
            #[inline]
            pub fn fromFaction(&self) -> u32 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<u32>(TradeLinkState::VT_FROMFACTION, Some(0))
                        .unwrap()
                }
            }
            #[inline]
            pub fn toFaction(&self) -> u32 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<u32>(TradeLinkState::VT_TOFACTION, Some(0))
                        .unwrap()
                }
            }
            #[inline]
            pub fn throughput(&self) -> i64 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<i64>(TradeLinkState::VT_THROUGHPUT, Some(0))
                        .unwrap()
                }
            }
            #[inline]
            pub fn tariff(&self) -> i64 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<i64>(TradeLinkState::VT_TARIFF, Some(0))
                        .unwrap()
                }
            }
            #[inline]
            pub fn knowledge(&self) -> Option<TradeLinkKnowledge<'a>> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<flatbuffers::ForwardsUOffset<TradeLinkKnowledge>>(
                            TradeLinkState::VT_KNOWLEDGE,
                            None,
                        )
                }
            }
            #[inline]
            pub fn fromTile(&self) -> u64 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<u64>(TradeLinkState::VT_FROMTILE, Some(0))
                        .unwrap()
                }
            }
            #[inline]
            pub fn toTile(&self) -> u64 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<u64>(TradeLinkState::VT_TOTILE, Some(0))
                        .unwrap()
                }
            }
            #[inline]
            pub fn pendingFragments(
                &self,
            ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<KnownTechFragment<'a>>>>
            {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab.get::<flatbuffers::ForwardsUOffset<
                        flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<KnownTechFragment>>,
                    >>(TradeLinkState::VT_PENDINGFRAGMENTS, None)
                }
            }
        }

        impl flatbuffers::Verifiable for TradeLinkState<'_> {
            #[inline]
            fn run_verifier(
                v: &mut flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                v.visit_table(pos)?
                    .visit_field::<u64>("entity", Self::VT_ENTITY, false)?
                    .visit_field::<u32>("fromFaction", Self::VT_FROMFACTION, false)?
                    .visit_field::<u32>("toFaction", Self::VT_TOFACTION, false)?
                    .visit_field::<i64>("throughput", Self::VT_THROUGHPUT, false)?
                    .visit_field::<i64>("tariff", Self::VT_TARIFF, false)?
                    .visit_field::<flatbuffers::ForwardsUOffset<TradeLinkKnowledge>>(
                        "knowledge",
                        Self::VT_KNOWLEDGE,
                        false,
                    )?
                    .visit_field::<u64>("fromTile", Self::VT_FROMTILE, false)?
                    .visit_field::<u64>("toTile", Self::VT_TOTILE, false)?
                    .visit_field::<flatbuffers::ForwardsUOffset<
                        flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<KnownTechFragment>>,
                    >>("pendingFragments", Self::VT_PENDINGFRAGMENTS, false)?
                    .finish();
                Ok(())
            }
        }
        pub struct TradeLinkStateArgs<'a> {
            pub entity: u64,
            pub fromFaction: u32,
            pub toFaction: u32,
            pub throughput: i64,
            pub tariff: i64,
            pub knowledge: Option<flatbuffers::WIPOffset<TradeLinkKnowledge<'a>>>,
            pub fromTile: u64,
            pub toTile: u64,
            pub pendingFragments: Option<
                flatbuffers::WIPOffset<
                    flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<KnownTechFragment<'a>>>,
                >,
            >,
        }
        impl<'a> Default for TradeLinkStateArgs<'a> {
            #[inline]
            fn default() -> Self {
                TradeLinkStateArgs {
                    entity: 0,
                    fromFaction: 0,
                    toFaction: 0,
                    throughput: 0,
                    tariff: 0,
                    knowledge: None,
                    fromTile: 0,
                    toTile: 0,
                    pendingFragments: None,
                }
            }
        }

        pub struct TradeLinkStateBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> TradeLinkStateBuilder<'a, 'b, A> {
            #[inline]
            pub fn add_entity(&mut self, entity: u64) {
                self.fbb_
                    .push_slot::<u64>(TradeLinkState::VT_ENTITY, entity, 0);
            }
            #[inline]
            pub fn add_fromFaction(&mut self, fromFaction: u32) {
                self.fbb_
                    .push_slot::<u32>(TradeLinkState::VT_FROMFACTION, fromFaction, 0);
            }
            #[inline]
            pub fn add_toFaction(&mut self, toFaction: u32) {
                self.fbb_
                    .push_slot::<u32>(TradeLinkState::VT_TOFACTION, toFaction, 0);
            }
            #[inline]
            pub fn add_throughput(&mut self, throughput: i64) {
                self.fbb_
                    .push_slot::<i64>(TradeLinkState::VT_THROUGHPUT, throughput, 0);
            }
            #[inline]
            pub fn add_tariff(&mut self, tariff: i64) {
                self.fbb_
                    .push_slot::<i64>(TradeLinkState::VT_TARIFF, tariff, 0);
            }
            #[inline]
            pub fn add_knowledge(
                &mut self,
                knowledge: flatbuffers::WIPOffset<TradeLinkKnowledge<'b>>,
            ) {
                self.fbb_
                    .push_slot_always::<flatbuffers::WIPOffset<TradeLinkKnowledge>>(
                        TradeLinkState::VT_KNOWLEDGE,
                        knowledge,
                    );
            }
            #[inline]
            pub fn add_fromTile(&mut self, fromTile: u64) {
                self.fbb_
                    .push_slot::<u64>(TradeLinkState::VT_FROMTILE, fromTile, 0);
            }
            #[inline]
            pub fn add_toTile(&mut self, toTile: u64) {
                self.fbb_
                    .push_slot::<u64>(TradeLinkState::VT_TOTILE, toTile, 0);
            }
            #[inline]
            pub fn add_pendingFragments(
                &mut self,
                pendingFragments: flatbuffers::WIPOffset<
                    flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<KnownTechFragment<'b>>>,
                >,
            ) {
                self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                    TradeLinkState::VT_PENDINGFRAGMENTS,
                    pendingFragments,
                );
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
            ) -> TradeLinkStateBuilder<'a, 'b, A> {
                let start = _fbb.start_table();
                TradeLinkStateBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<TradeLinkState<'a>> {
                let o = self.fbb_.end_table(self.start_);
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        impl core::fmt::Debug for TradeLinkState<'_> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                let mut ds = f.debug_struct("TradeLinkState");
                ds.field("entity", &self.entity());
                ds.field("fromFaction", &self.fromFaction());
                ds.field("toFaction", &self.toFaction());
                ds.field("throughput", &self.throughput());
                ds.field("tariff", &self.tariff());
                ds.field("knowledge", &self.knowledge());
                ds.field("fromTile", &self.fromTile());
                ds.field("toTile", &self.toTile());
                ds.field("pendingFragments", &self.pendingFragments());
                ds.finish()
            }
        }
        pub enum DiscoveryProgressEntryOffset {}
        #[derive(Copy, Clone, PartialEq)]

        pub struct DiscoveryProgressEntry<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for DiscoveryProgressEntry<'a> {
            type Inner = DiscoveryProgressEntry<'a>;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: unsafe { flatbuffers::Table::new(buf, loc) },
                }
            }
        }

        impl<'a> DiscoveryProgressEntry<'a> {
            pub const VT_FACTION: flatbuffers::VOffsetT = 4;
            pub const VT_DISCOVERY: flatbuffers::VOffsetT = 6;
            pub const VT_PROGRESS: flatbuffers::VOffsetT = 8;

            #[inline]
            pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                DiscoveryProgressEntry { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<
                'bldr: 'args,
                'args: 'mut_bldr,
                'mut_bldr,
                A: flatbuffers::Allocator + 'bldr,
            >(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
                args: &'args DiscoveryProgressEntryArgs,
            ) -> flatbuffers::WIPOffset<DiscoveryProgressEntry<'bldr>> {
                let mut builder = DiscoveryProgressEntryBuilder::new(_fbb);
                builder.add_progress(args.progress);
                builder.add_discovery(args.discovery);
                builder.add_faction(args.faction);
                builder.finish()
            }

            #[inline]
            pub fn faction(&self) -> u32 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<u32>(DiscoveryProgressEntry::VT_FACTION, Some(0))
                        .unwrap()
                }
            }
            #[inline]
            pub fn discovery(&self) -> u32 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<u32>(DiscoveryProgressEntry::VT_DISCOVERY, Some(0))
                        .unwrap()
                }
            }
            #[inline]
            pub fn progress(&self) -> i64 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<i64>(DiscoveryProgressEntry::VT_PROGRESS, Some(0))
                        .unwrap()
                }
            }
        }

        impl flatbuffers::Verifiable for DiscoveryProgressEntry<'_> {
            #[inline]
            fn run_verifier(
                v: &mut flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                v.visit_table(pos)?
                    .visit_field::<u32>("faction", Self::VT_FACTION, false)?
                    .visit_field::<u32>("discovery", Self::VT_DISCOVERY, false)?
                    .visit_field::<i64>("progress", Self::VT_PROGRESS, false)?
                    .finish();
                Ok(())
            }
        }
        pub struct DiscoveryProgressEntryArgs {
            pub faction: u32,
            pub discovery: u32,
            pub progress: i64,
        }
        impl<'a> Default for DiscoveryProgressEntryArgs {
            #[inline]
            fn default() -> Self {
                DiscoveryProgressEntryArgs {
                    faction: 0,
                    discovery: 0,
                    progress: 0,
                }
            }
        }

        pub struct DiscoveryProgressEntryBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> DiscoveryProgressEntryBuilder<'a, 'b, A> {
            #[inline]
            pub fn add_faction(&mut self, faction: u32) {
                self.fbb_
                    .push_slot::<u32>(DiscoveryProgressEntry::VT_FACTION, faction, 0);
            }
            #[inline]
            pub fn add_discovery(&mut self, discovery: u32) {
                self.fbb_
                    .push_slot::<u32>(DiscoveryProgressEntry::VT_DISCOVERY, discovery, 0);
            }
            #[inline]
            pub fn add_progress(&mut self, progress: i64) {
                self.fbb_
                    .push_slot::<i64>(DiscoveryProgressEntry::VT_PROGRESS, progress, 0);
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
            ) -> DiscoveryProgressEntryBuilder<'a, 'b, A> {
                let start = _fbb.start_table();
                DiscoveryProgressEntryBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<DiscoveryProgressEntry<'a>> {
                let o = self.fbb_.end_table(self.start_);
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        impl core::fmt::Debug for DiscoveryProgressEntry<'_> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                let mut ds = f.debug_struct("DiscoveryProgressEntry");
                ds.field("faction", &self.faction());
                ds.field("discovery", &self.discovery());
                ds.field("progress", &self.progress());
                ds.finish()
            }
        }
        pub enum WorldSnapshotOffset {}
        #[derive(Copy, Clone, PartialEq)]

        pub struct WorldSnapshot<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for WorldSnapshot<'a> {
            type Inner = WorldSnapshot<'a>;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: unsafe { flatbuffers::Table::new(buf, loc) },
                }
            }
        }

        impl<'a> WorldSnapshot<'a> {
            pub const VT_HEADER: flatbuffers::VOffsetT = 4;
            pub const VT_TILES: flatbuffers::VOffsetT = 6;
            pub const VT_LOGISTICS: flatbuffers::VOffsetT = 8;
            pub const VT_TRADELINKS: flatbuffers::VOffsetT = 10;
            pub const VT_POPULATIONS: flatbuffers::VOffsetT = 12;
            pub const VT_POWER: flatbuffers::VOffsetT = 14;
            pub const VT_TERRAINOVERLAY: flatbuffers::VOffsetT = 16;
            pub const VT_AXISBIAS: flatbuffers::VOffsetT = 18;
            pub const VT_SENTIMENT: flatbuffers::VOffsetT = 20;
            pub const VT_GENERATIONS: flatbuffers::VOffsetT = 22;
            pub const VT_CORRUPTION: flatbuffers::VOffsetT = 24;
            pub const VT_INFLUENCERS: flatbuffers::VOffsetT = 26;
            pub const VT_CULTURELAYERS: flatbuffers::VOffsetT = 28;
            pub const VT_CULTURETENSIONS: flatbuffers::VOffsetT = 30;
            pub const VT_DISCOVERYPROGRESS: flatbuffers::VOffsetT = 32;

            #[inline]
            pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                WorldSnapshot { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<
                'bldr: 'args,
                'args: 'mut_bldr,
                'mut_bldr,
                A: flatbuffers::Allocator + 'bldr,
            >(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
                args: &'args WorldSnapshotArgs<'args>,
            ) -> flatbuffers::WIPOffset<WorldSnapshot<'bldr>> {
                let mut builder = WorldSnapshotBuilder::new(_fbb);
                if let Some(x) = args.discoveryProgress {
                    builder.add_discoveryProgress(x);
                }
                if let Some(x) = args.cultureTensions {
                    builder.add_cultureTensions(x);
                }
                if let Some(x) = args.cultureLayers {
                    builder.add_cultureLayers(x);
                }
                if let Some(x) = args.influencers {
                    builder.add_influencers(x);
                }
                if let Some(x) = args.corruption {
                    builder.add_corruption(x);
                }
                if let Some(x) = args.generations {
                    builder.add_generations(x);
                }
                if let Some(x) = args.sentiment {
                    builder.add_sentiment(x);
                }
                if let Some(x) = args.axisBias {
                    builder.add_axisBias(x);
                }
                if let Some(x) = args.terrainOverlay {
                    builder.add_terrainOverlay(x);
                }
                if let Some(x) = args.power {
                    builder.add_power(x);
                }
                if let Some(x) = args.populations {
                    builder.add_populations(x);
                }
                if let Some(x) = args.tradeLinks {
                    builder.add_tradeLinks(x);
                }
                if let Some(x) = args.logistics {
                    builder.add_logistics(x);
                }
                if let Some(x) = args.tiles {
                    builder.add_tiles(x);
                }
                if let Some(x) = args.header {
                    builder.add_header(x);
                }
                builder.finish()
            }

            #[inline]
            pub fn header(&self) -> Option<SnapshotHeader<'a>> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<flatbuffers::ForwardsUOffset<SnapshotHeader>>(
                            WorldSnapshot::VT_HEADER,
                            None,
                        )
                }
            }
            #[inline]
            pub fn tiles(
                &self,
            ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<TileState<'a>>>>
            {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab.get::<flatbuffers::ForwardsUOffset<
                        flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<TileState>>,
                    >>(WorldSnapshot::VT_TILES, None)
                }
            }
            #[inline]
            pub fn logistics(
                &self,
            ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<LogisticsLinkState<'a>>>>
            {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab.get::<flatbuffers::ForwardsUOffset<
                        flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<LogisticsLinkState>>,
                    >>(WorldSnapshot::VT_LOGISTICS, None)
                }
            }
            #[inline]
            pub fn tradeLinks(
                &self,
            ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<TradeLinkState<'a>>>>
            {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab.get::<flatbuffers::ForwardsUOffset<
                        flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<TradeLinkState>>,
                    >>(WorldSnapshot::VT_TRADELINKS, None)
                }
            }
            #[inline]
            pub fn populations(
                &self,
            ) -> Option<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<PopulationCohortState<'a>>>,
            > {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab.get::<flatbuffers::ForwardsUOffset<
                        flatbuffers::Vector<
                            'a,
                            flatbuffers::ForwardsUOffset<PopulationCohortState>,
                        >,
                    >>(WorldSnapshot::VT_POPULATIONS, None)
                }
            }
            #[inline]
            pub fn power(
                &self,
            ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<PowerNodeState<'a>>>>
            {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab.get::<flatbuffers::ForwardsUOffset<
                        flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<PowerNodeState>>,
                    >>(WorldSnapshot::VT_POWER, None)
                }
            }
            #[inline]
            pub fn terrainOverlay(&self) -> Option<TerrainOverlay<'a>> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<flatbuffers::ForwardsUOffset<TerrainOverlay>>(
                            WorldSnapshot::VT_TERRAINOVERLAY,
                            None,
                        )
                }
            }
            #[inline]
            pub fn axisBias(&self) -> Option<AxisBiasState<'a>> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<flatbuffers::ForwardsUOffset<AxisBiasState>>(
                            WorldSnapshot::VT_AXISBIAS,
                            None,
                        )
                }
            }
            #[inline]
            pub fn sentiment(&self) -> Option<SentimentTelemetryState<'a>> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<flatbuffers::ForwardsUOffset<SentimentTelemetryState>>(
                            WorldSnapshot::VT_SENTIMENT,
                            None,
                        )
                }
            }
            #[inline]
            pub fn generations(
                &self,
            ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<GenerationState<'a>>>>
            {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab.get::<flatbuffers::ForwardsUOffset<
                        flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<GenerationState>>,
                    >>(WorldSnapshot::VT_GENERATIONS, None)
                }
            }
            #[inline]
            pub fn corruption(&self) -> Option<CorruptionLedger<'a>> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<flatbuffers::ForwardsUOffset<CorruptionLedger>>(
                            WorldSnapshot::VT_CORRUPTION,
                            None,
                        )
                }
            }
            #[inline]
            pub fn influencers(
                &self,
            ) -> Option<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<InfluentialIndividualState<'a>>,
                >,
            > {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab.get::<flatbuffers::ForwardsUOffset<
                        flatbuffers::Vector<
                            'a,
                            flatbuffers::ForwardsUOffset<InfluentialIndividualState>,
                        >,
                    >>(WorldSnapshot::VT_INFLUENCERS, None)
                }
            }
            #[inline]
            pub fn cultureLayers(
                &self,
            ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<CultureLayerState<'a>>>>
            {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab.get::<flatbuffers::ForwardsUOffset<
                        flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<CultureLayerState>>,
                    >>(WorldSnapshot::VT_CULTURELAYERS, None)
                }
            }
            #[inline]
            pub fn cultureTensions(
                &self,
            ) -> Option<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<CultureTensionState<'a>>>,
            > {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab.get::<flatbuffers::ForwardsUOffset<
                        flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<CultureTensionState>>,
                    >>(WorldSnapshot::VT_CULTURETENSIONS, None)
                }
            }
            #[inline]
            pub fn discoveryProgress(
                &self,
            ) -> Option<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<DiscoveryProgressEntry<'a>>>,
            > {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab.get::<flatbuffers::ForwardsUOffset<
                        flatbuffers::Vector<
                            'a,
                            flatbuffers::ForwardsUOffset<DiscoveryProgressEntry>,
                        >,
                    >>(WorldSnapshot::VT_DISCOVERYPROGRESS, None)
                }
            }
        }

        impl flatbuffers::Verifiable for WorldSnapshot<'_> {
            #[inline]
            fn run_verifier(
                v: &mut flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                v.visit_table(pos)?
                    .visit_field::<flatbuffers::ForwardsUOffset<SnapshotHeader>>(
                        "header",
                        Self::VT_HEADER,
                        false,
                    )?
                    .visit_field::<flatbuffers::ForwardsUOffset<
                        flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<TileState>>,
                    >>("tiles", Self::VT_TILES, false)?
                    .visit_field::<flatbuffers::ForwardsUOffset<
                        flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<LogisticsLinkState>>,
                    >>("logistics", Self::VT_LOGISTICS, false)?
                    .visit_field::<flatbuffers::ForwardsUOffset<
                        flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<TradeLinkState>>,
                    >>("tradeLinks", Self::VT_TRADELINKS, false)?
                    .visit_field::<flatbuffers::ForwardsUOffset<
                        flatbuffers::Vector<
                            '_,
                            flatbuffers::ForwardsUOffset<PopulationCohortState>,
                        >,
                    >>("populations", Self::VT_POPULATIONS, false)?
                    .visit_field::<flatbuffers::ForwardsUOffset<
                        flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<PowerNodeState>>,
                    >>("power", Self::VT_POWER, false)?
                    .visit_field::<flatbuffers::ForwardsUOffset<TerrainOverlay>>(
                        "terrainOverlay",
                        Self::VT_TERRAINOVERLAY,
                        false,
                    )?
                    .visit_field::<flatbuffers::ForwardsUOffset<AxisBiasState>>(
                        "axisBias",
                        Self::VT_AXISBIAS,
                        false,
                    )?
                    .visit_field::<flatbuffers::ForwardsUOffset<SentimentTelemetryState>>(
                        "sentiment",
                        Self::VT_SENTIMENT,
                        false,
                    )?
                    .visit_field::<flatbuffers::ForwardsUOffset<
                        flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<GenerationState>>,
                    >>("generations", Self::VT_GENERATIONS, false)?
                    .visit_field::<flatbuffers::ForwardsUOffset<CorruptionLedger>>(
                        "corruption",
                        Self::VT_CORRUPTION,
                        false,
                    )?
                    .visit_field::<flatbuffers::ForwardsUOffset<
                        flatbuffers::Vector<
                            '_,
                            flatbuffers::ForwardsUOffset<InfluentialIndividualState>,
                        >,
                    >>("influencers", Self::VT_INFLUENCERS, false)?
                    .visit_field::<flatbuffers::ForwardsUOffset<
                        flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<CultureLayerState>>,
                    >>("cultureLayers", Self::VT_CULTURELAYERS, false)?
                    .visit_field::<flatbuffers::ForwardsUOffset<
                        flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<CultureTensionState>>,
                    >>("cultureTensions", Self::VT_CULTURETENSIONS, false)?
                    .visit_field::<flatbuffers::ForwardsUOffset<
                        flatbuffers::Vector<
                            '_,
                            flatbuffers::ForwardsUOffset<DiscoveryProgressEntry>,
                        >,
                    >>("discoveryProgress", Self::VT_DISCOVERYPROGRESS, false)?
                    .finish();
                Ok(())
            }
        }
        pub struct WorldSnapshotArgs<'a> {
            pub header: Option<flatbuffers::WIPOffset<SnapshotHeader<'a>>>,
            pub tiles: Option<
                flatbuffers::WIPOffset<
                    flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<TileState<'a>>>,
                >,
            >,
            pub logistics: Option<
                flatbuffers::WIPOffset<
                    flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<LogisticsLinkState<'a>>>,
                >,
            >,
            pub tradeLinks: Option<
                flatbuffers::WIPOffset<
                    flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<TradeLinkState<'a>>>,
                >,
            >,
            pub populations: Option<
                flatbuffers::WIPOffset<
                    flatbuffers::Vector<
                        'a,
                        flatbuffers::ForwardsUOffset<PopulationCohortState<'a>>,
                    >,
                >,
            >,
            pub power: Option<
                flatbuffers::WIPOffset<
                    flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<PowerNodeState<'a>>>,
                >,
            >,
            pub terrainOverlay: Option<flatbuffers::WIPOffset<TerrainOverlay<'a>>>,
            pub axisBias: Option<flatbuffers::WIPOffset<AxisBiasState<'a>>>,
            pub sentiment: Option<flatbuffers::WIPOffset<SentimentTelemetryState<'a>>>,
            pub generations: Option<
                flatbuffers::WIPOffset<
                    flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<GenerationState<'a>>>,
                >,
            >,
            pub corruption: Option<flatbuffers::WIPOffset<CorruptionLedger<'a>>>,
            pub influencers: Option<
                flatbuffers::WIPOffset<
                    flatbuffers::Vector<
                        'a,
                        flatbuffers::ForwardsUOffset<InfluentialIndividualState<'a>>,
                    >,
                >,
            >,
            pub cultureLayers: Option<
                flatbuffers::WIPOffset<
                    flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<CultureLayerState<'a>>>,
                >,
            >,
            pub cultureTensions: Option<
                flatbuffers::WIPOffset<
                    flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<CultureTensionState<'a>>>,
                >,
            >,
            pub discoveryProgress: Option<
                flatbuffers::WIPOffset<
                    flatbuffers::Vector<
                        'a,
                        flatbuffers::ForwardsUOffset<DiscoveryProgressEntry<'a>>,
                    >,
                >,
            >,
        }
        impl<'a> Default for WorldSnapshotArgs<'a> {
            #[inline]
            fn default() -> Self {
                WorldSnapshotArgs {
                    header: None,
                    tiles: None,
                    logistics: None,
                    tradeLinks: None,
                    populations: None,
                    power: None,
                    terrainOverlay: None,
                    axisBias: None,
                    sentiment: None,
                    generations: None,
                    corruption: None,
                    influencers: None,
                    cultureLayers: None,
                    cultureTensions: None,
                    discoveryProgress: None,
                }
            }
        }

        pub struct WorldSnapshotBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> WorldSnapshotBuilder<'a, 'b, A> {
            #[inline]
            pub fn add_header(&mut self, header: flatbuffers::WIPOffset<SnapshotHeader<'b>>) {
                self.fbb_
                    .push_slot_always::<flatbuffers::WIPOffset<SnapshotHeader>>(
                        WorldSnapshot::VT_HEADER,
                        header,
                    );
            }
            #[inline]
            pub fn add_tiles(
                &mut self,
                tiles: flatbuffers::WIPOffset<
                    flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<TileState<'b>>>,
                >,
            ) {
                self.fbb_
                    .push_slot_always::<flatbuffers::WIPOffset<_>>(WorldSnapshot::VT_TILES, tiles);
            }
            #[inline]
            pub fn add_logistics(
                &mut self,
                logistics: flatbuffers::WIPOffset<
                    flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<LogisticsLinkState<'b>>>,
                >,
            ) {
                self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                    WorldSnapshot::VT_LOGISTICS,
                    logistics,
                );
            }
            #[inline]
            pub fn add_tradeLinks(
                &mut self,
                tradeLinks: flatbuffers::WIPOffset<
                    flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<TradeLinkState<'b>>>,
                >,
            ) {
                self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                    WorldSnapshot::VT_TRADELINKS,
                    tradeLinks,
                );
            }
            #[inline]
            pub fn add_populations(
                &mut self,
                populations: flatbuffers::WIPOffset<
                    flatbuffers::Vector<
                        'b,
                        flatbuffers::ForwardsUOffset<PopulationCohortState<'b>>,
                    >,
                >,
            ) {
                self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                    WorldSnapshot::VT_POPULATIONS,
                    populations,
                );
            }
            #[inline]
            pub fn add_power(
                &mut self,
                power: flatbuffers::WIPOffset<
                    flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<PowerNodeState<'b>>>,
                >,
            ) {
                self.fbb_
                    .push_slot_always::<flatbuffers::WIPOffset<_>>(WorldSnapshot::VT_POWER, power);
            }
            #[inline]
            pub fn add_terrainOverlay(
                &mut self,
                terrainOverlay: flatbuffers::WIPOffset<TerrainOverlay<'b>>,
            ) {
                self.fbb_
                    .push_slot_always::<flatbuffers::WIPOffset<TerrainOverlay>>(
                        WorldSnapshot::VT_TERRAINOVERLAY,
                        terrainOverlay,
                    );
            }
            #[inline]
            pub fn add_axisBias(&mut self, axisBias: flatbuffers::WIPOffset<AxisBiasState<'b>>) {
                self.fbb_
                    .push_slot_always::<flatbuffers::WIPOffset<AxisBiasState>>(
                        WorldSnapshot::VT_AXISBIAS,
                        axisBias,
                    );
            }
            #[inline]
            pub fn add_sentiment(
                &mut self,
                sentiment: flatbuffers::WIPOffset<SentimentTelemetryState<'b>>,
            ) {
                self.fbb_
                    .push_slot_always::<flatbuffers::WIPOffset<SentimentTelemetryState>>(
                        WorldSnapshot::VT_SENTIMENT,
                        sentiment,
                    );
            }
            #[inline]
            pub fn add_generations(
                &mut self,
                generations: flatbuffers::WIPOffset<
                    flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<GenerationState<'b>>>,
                >,
            ) {
                self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                    WorldSnapshot::VT_GENERATIONS,
                    generations,
                );
            }
            #[inline]
            pub fn add_corruption(
                &mut self,
                corruption: flatbuffers::WIPOffset<CorruptionLedger<'b>>,
            ) {
                self.fbb_
                    .push_slot_always::<flatbuffers::WIPOffset<CorruptionLedger>>(
                        WorldSnapshot::VT_CORRUPTION,
                        corruption,
                    );
            }
            #[inline]
            pub fn add_influencers(
                &mut self,
                influencers: flatbuffers::WIPOffset<
                    flatbuffers::Vector<
                        'b,
                        flatbuffers::ForwardsUOffset<InfluentialIndividualState<'b>>,
                    >,
                >,
            ) {
                self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                    WorldSnapshot::VT_INFLUENCERS,
                    influencers,
                );
            }
            #[inline]
            pub fn add_cultureLayers(
                &mut self,
                cultureLayers: flatbuffers::WIPOffset<
                    flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<CultureLayerState<'b>>>,
                >,
            ) {
                self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                    WorldSnapshot::VT_CULTURELAYERS,
                    cultureLayers,
                );
            }
            #[inline]
            pub fn add_cultureTensions(
                &mut self,
                cultureTensions: flatbuffers::WIPOffset<
                    flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<CultureTensionState<'b>>>,
                >,
            ) {
                self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                    WorldSnapshot::VT_CULTURETENSIONS,
                    cultureTensions,
                );
            }
            #[inline]
            pub fn add_discoveryProgress(
                &mut self,
                discoveryProgress: flatbuffers::WIPOffset<
                    flatbuffers::Vector<
                        'b,
                        flatbuffers::ForwardsUOffset<DiscoveryProgressEntry<'b>>,
                    >,
                >,
            ) {
                self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                    WorldSnapshot::VT_DISCOVERYPROGRESS,
                    discoveryProgress,
                );
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
            ) -> WorldSnapshotBuilder<'a, 'b, A> {
                let start = _fbb.start_table();
                WorldSnapshotBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<WorldSnapshot<'a>> {
                let o = self.fbb_.end_table(self.start_);
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        impl core::fmt::Debug for WorldSnapshot<'_> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                let mut ds = f.debug_struct("WorldSnapshot");
                ds.field("header", &self.header());
                ds.field("tiles", &self.tiles());
                ds.field("logistics", &self.logistics());
                ds.field("tradeLinks", &self.tradeLinks());
                ds.field("populations", &self.populations());
                ds.field("power", &self.power());
                ds.field("terrainOverlay", &self.terrainOverlay());
                ds.field("axisBias", &self.axisBias());
                ds.field("sentiment", &self.sentiment());
                ds.field("generations", &self.generations());
                ds.field("corruption", &self.corruption());
                ds.field("influencers", &self.influencers());
                ds.field("cultureLayers", &self.cultureLayers());
                ds.field("cultureTensions", &self.cultureTensions());
                ds.field("discoveryProgress", &self.discoveryProgress());
                ds.finish()
            }
        }
        pub enum WorldDeltaOffset {}
        #[derive(Copy, Clone, PartialEq)]

        pub struct WorldDelta<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for WorldDelta<'a> {
            type Inner = WorldDelta<'a>;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: unsafe { flatbuffers::Table::new(buf, loc) },
                }
            }
        }

        impl<'a> WorldDelta<'a> {
            pub const VT_HEADER: flatbuffers::VOffsetT = 4;
            pub const VT_TILES: flatbuffers::VOffsetT = 6;
            pub const VT_REMOVEDTILES: flatbuffers::VOffsetT = 8;
            pub const VT_LOGISTICS: flatbuffers::VOffsetT = 10;
            pub const VT_REMOVEDLOGISTICS: flatbuffers::VOffsetT = 12;
            pub const VT_TRADELINKS: flatbuffers::VOffsetT = 14;
            pub const VT_REMOVEDTRADELINKS: flatbuffers::VOffsetT = 16;
            pub const VT_POPULATIONS: flatbuffers::VOffsetT = 18;
            pub const VT_REMOVEDPOPULATIONS: flatbuffers::VOffsetT = 20;
            pub const VT_POWER: flatbuffers::VOffsetT = 22;
            pub const VT_REMOVEDPOWER: flatbuffers::VOffsetT = 24;
            pub const VT_AXISBIAS: flatbuffers::VOffsetT = 26;
            pub const VT_SENTIMENT: flatbuffers::VOffsetT = 28;
            pub const VT_GENERATIONS: flatbuffers::VOffsetT = 30;
            pub const VT_REMOVEDGENERATIONS: flatbuffers::VOffsetT = 32;
            pub const VT_CORRUPTION: flatbuffers::VOffsetT = 34;
            pub const VT_INFLUENCERS: flatbuffers::VOffsetT = 36;
            pub const VT_REMOVEDINFLUENCERS: flatbuffers::VOffsetT = 38;
            pub const VT_TERRAINOVERLAY: flatbuffers::VOffsetT = 40;
            pub const VT_CULTURELAYERS: flatbuffers::VOffsetT = 42;
            pub const VT_REMOVEDCULTURELAYERS: flatbuffers::VOffsetT = 44;
            pub const VT_CULTURETENSIONS: flatbuffers::VOffsetT = 46;
            pub const VT_DISCOVERYPROGRESS: flatbuffers::VOffsetT = 48;

            #[inline]
            pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                WorldDelta { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<
                'bldr: 'args,
                'args: 'mut_bldr,
                'mut_bldr,
                A: flatbuffers::Allocator + 'bldr,
            >(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
                args: &'args WorldDeltaArgs<'args>,
            ) -> flatbuffers::WIPOffset<WorldDelta<'bldr>> {
                let mut builder = WorldDeltaBuilder::new(_fbb);
                if let Some(x) = args.discoveryProgress {
                    builder.add_discoveryProgress(x);
                }
                if let Some(x) = args.cultureTensions {
                    builder.add_cultureTensions(x);
                }
                if let Some(x) = args.removedCultureLayers {
                    builder.add_removedCultureLayers(x);
                }
                if let Some(x) = args.cultureLayers {
                    builder.add_cultureLayers(x);
                }
                if let Some(x) = args.terrainOverlay {
                    builder.add_terrainOverlay(x);
                }
                if let Some(x) = args.removedInfluencers {
                    builder.add_removedInfluencers(x);
                }
                if let Some(x) = args.influencers {
                    builder.add_influencers(x);
                }
                if let Some(x) = args.corruption {
                    builder.add_corruption(x);
                }
                if let Some(x) = args.removedGenerations {
                    builder.add_removedGenerations(x);
                }
                if let Some(x) = args.generations {
                    builder.add_generations(x);
                }
                if let Some(x) = args.sentiment {
                    builder.add_sentiment(x);
                }
                if let Some(x) = args.axisBias {
                    builder.add_axisBias(x);
                }
                if let Some(x) = args.removedPower {
                    builder.add_removedPower(x);
                }
                if let Some(x) = args.power {
                    builder.add_power(x);
                }
                if let Some(x) = args.removedPopulations {
                    builder.add_removedPopulations(x);
                }
                if let Some(x) = args.populations {
                    builder.add_populations(x);
                }
                if let Some(x) = args.removedTradeLinks {
                    builder.add_removedTradeLinks(x);
                }
                if let Some(x) = args.tradeLinks {
                    builder.add_tradeLinks(x);
                }
                if let Some(x) = args.removedLogistics {
                    builder.add_removedLogistics(x);
                }
                if let Some(x) = args.logistics {
                    builder.add_logistics(x);
                }
                if let Some(x) = args.removedTiles {
                    builder.add_removedTiles(x);
                }
                if let Some(x) = args.tiles {
                    builder.add_tiles(x);
                }
                if let Some(x) = args.header {
                    builder.add_header(x);
                }
                builder.finish()
            }

            #[inline]
            pub fn header(&self) -> Option<SnapshotHeader<'a>> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<flatbuffers::ForwardsUOffset<SnapshotHeader>>(
                            WorldDelta::VT_HEADER,
                            None,
                        )
                }
            }
            #[inline]
            pub fn tiles(
                &self,
            ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<TileState<'a>>>>
            {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab.get::<flatbuffers::ForwardsUOffset<
                        flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<TileState>>,
                    >>(WorldDelta::VT_TILES, None)
                }
            }
            #[inline]
            pub fn removedTiles(&self) -> Option<flatbuffers::Vector<'a, u64>> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u64>>>(
                            WorldDelta::VT_REMOVEDTILES,
                            None,
                        )
                }
            }
            #[inline]
            pub fn logistics(
                &self,
            ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<LogisticsLinkState<'a>>>>
            {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab.get::<flatbuffers::ForwardsUOffset<
                        flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<LogisticsLinkState>>,
                    >>(WorldDelta::VT_LOGISTICS, None)
                }
            }
            #[inline]
            pub fn removedLogistics(&self) -> Option<flatbuffers::Vector<'a, u64>> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u64>>>(
                            WorldDelta::VT_REMOVEDLOGISTICS,
                            None,
                        )
                }
            }
            #[inline]
            pub fn tradeLinks(
                &self,
            ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<TradeLinkState<'a>>>>
            {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab.get::<flatbuffers::ForwardsUOffset<
                        flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<TradeLinkState>>,
                    >>(WorldDelta::VT_TRADELINKS, None)
                }
            }
            #[inline]
            pub fn removedTradeLinks(&self) -> Option<flatbuffers::Vector<'a, u64>> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u64>>>(
                            WorldDelta::VT_REMOVEDTRADELINKS,
                            None,
                        )
                }
            }
            #[inline]
            pub fn populations(
                &self,
            ) -> Option<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<PopulationCohortState<'a>>>,
            > {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab.get::<flatbuffers::ForwardsUOffset<
                        flatbuffers::Vector<
                            'a,
                            flatbuffers::ForwardsUOffset<PopulationCohortState>,
                        >,
                    >>(WorldDelta::VT_POPULATIONS, None)
                }
            }
            #[inline]
            pub fn removedPopulations(&self) -> Option<flatbuffers::Vector<'a, u64>> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u64>>>(
                            WorldDelta::VT_REMOVEDPOPULATIONS,
                            None,
                        )
                }
            }
            #[inline]
            pub fn power(
                &self,
            ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<PowerNodeState<'a>>>>
            {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab.get::<flatbuffers::ForwardsUOffset<
                        flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<PowerNodeState>>,
                    >>(WorldDelta::VT_POWER, None)
                }
            }
            #[inline]
            pub fn removedPower(&self) -> Option<flatbuffers::Vector<'a, u64>> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u64>>>(
                            WorldDelta::VT_REMOVEDPOWER,
                            None,
                        )
                }
            }
            #[inline]
            pub fn axisBias(&self) -> Option<AxisBiasState<'a>> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<flatbuffers::ForwardsUOffset<AxisBiasState>>(
                            WorldDelta::VT_AXISBIAS,
                            None,
                        )
                }
            }
            #[inline]
            pub fn sentiment(&self) -> Option<SentimentTelemetryState<'a>> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<flatbuffers::ForwardsUOffset<SentimentTelemetryState>>(
                            WorldDelta::VT_SENTIMENT,
                            None,
                        )
                }
            }
            #[inline]
            pub fn generations(
                &self,
            ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<GenerationState<'a>>>>
            {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab.get::<flatbuffers::ForwardsUOffset<
                        flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<GenerationState>>,
                    >>(WorldDelta::VT_GENERATIONS, None)
                }
            }
            #[inline]
            pub fn removedGenerations(&self) -> Option<flatbuffers::Vector<'a, u16>> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u16>>>(
                            WorldDelta::VT_REMOVEDGENERATIONS,
                            None,
                        )
                }
            }
            #[inline]
            pub fn corruption(&self) -> Option<CorruptionLedger<'a>> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<flatbuffers::ForwardsUOffset<CorruptionLedger>>(
                            WorldDelta::VT_CORRUPTION,
                            None,
                        )
                }
            }
            #[inline]
            pub fn influencers(
                &self,
            ) -> Option<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<InfluentialIndividualState<'a>>,
                >,
            > {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab.get::<flatbuffers::ForwardsUOffset<
                        flatbuffers::Vector<
                            'a,
                            flatbuffers::ForwardsUOffset<InfluentialIndividualState>,
                        >,
                    >>(WorldDelta::VT_INFLUENCERS, None)
                }
            }
            #[inline]
            pub fn removedInfluencers(&self) -> Option<flatbuffers::Vector<'a, u32>> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u32>>>(
                            WorldDelta::VT_REMOVEDINFLUENCERS,
                            None,
                        )
                }
            }
            #[inline]
            pub fn terrainOverlay(&self) -> Option<TerrainOverlay<'a>> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<flatbuffers::ForwardsUOffset<TerrainOverlay>>(
                            WorldDelta::VT_TERRAINOVERLAY,
                            None,
                        )
                }
            }
            #[inline]
            pub fn cultureLayers(
                &self,
            ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<CultureLayerState<'a>>>>
            {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab.get::<flatbuffers::ForwardsUOffset<
                        flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<CultureLayerState>>,
                    >>(WorldDelta::VT_CULTURELAYERS, None)
                }
            }
            #[inline]
            pub fn removedCultureLayers(&self) -> Option<flatbuffers::Vector<'a, u32>> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u32>>>(
                            WorldDelta::VT_REMOVEDCULTURELAYERS,
                            None,
                        )
                }
            }
            #[inline]
            pub fn cultureTensions(
                &self,
            ) -> Option<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<CultureTensionState<'a>>>,
            > {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab.get::<flatbuffers::ForwardsUOffset<
                        flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<CultureTensionState>>,
                    >>(WorldDelta::VT_CULTURETENSIONS, None)
                }
            }
            #[inline]
            pub fn discoveryProgress(
                &self,
            ) -> Option<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<DiscoveryProgressEntry<'a>>>,
            > {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab.get::<flatbuffers::ForwardsUOffset<
                        flatbuffers::Vector<
                            'a,
                            flatbuffers::ForwardsUOffset<DiscoveryProgressEntry>,
                        >,
                    >>(WorldDelta::VT_DISCOVERYPROGRESS, None)
                }
            }
        }

        impl flatbuffers::Verifiable for WorldDelta<'_> {
            #[inline]
            fn run_verifier(
                v: &mut flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                v.visit_table(pos)?
                    .visit_field::<flatbuffers::ForwardsUOffset<SnapshotHeader>>(
                        "header",
                        Self::VT_HEADER,
                        false,
                    )?
                    .visit_field::<flatbuffers::ForwardsUOffset<
                        flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<TileState>>,
                    >>("tiles", Self::VT_TILES, false)?
                    .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u64>>>(
                        "removedTiles",
                        Self::VT_REMOVEDTILES,
                        false,
                    )?
                    .visit_field::<flatbuffers::ForwardsUOffset<
                        flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<LogisticsLinkState>>,
                    >>("logistics", Self::VT_LOGISTICS, false)?
                    .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u64>>>(
                        "removedLogistics",
                        Self::VT_REMOVEDLOGISTICS,
                        false,
                    )?
                    .visit_field::<flatbuffers::ForwardsUOffset<
                        flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<TradeLinkState>>,
                    >>("tradeLinks", Self::VT_TRADELINKS, false)?
                    .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u64>>>(
                        "removedTradeLinks",
                        Self::VT_REMOVEDTRADELINKS,
                        false,
                    )?
                    .visit_field::<flatbuffers::ForwardsUOffset<
                        flatbuffers::Vector<
                            '_,
                            flatbuffers::ForwardsUOffset<PopulationCohortState>,
                        >,
                    >>("populations", Self::VT_POPULATIONS, false)?
                    .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u64>>>(
                        "removedPopulations",
                        Self::VT_REMOVEDPOPULATIONS,
                        false,
                    )?
                    .visit_field::<flatbuffers::ForwardsUOffset<
                        flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<PowerNodeState>>,
                    >>("power", Self::VT_POWER, false)?
                    .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u64>>>(
                        "removedPower",
                        Self::VT_REMOVEDPOWER,
                        false,
                    )?
                    .visit_field::<flatbuffers::ForwardsUOffset<AxisBiasState>>(
                        "axisBias",
                        Self::VT_AXISBIAS,
                        false,
                    )?
                    .visit_field::<flatbuffers::ForwardsUOffset<SentimentTelemetryState>>(
                        "sentiment",
                        Self::VT_SENTIMENT,
                        false,
                    )?
                    .visit_field::<flatbuffers::ForwardsUOffset<
                        flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<GenerationState>>,
                    >>("generations", Self::VT_GENERATIONS, false)?
                    .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u16>>>(
                        "removedGenerations",
                        Self::VT_REMOVEDGENERATIONS,
                        false,
                    )?
                    .visit_field::<flatbuffers::ForwardsUOffset<CorruptionLedger>>(
                        "corruption",
                        Self::VT_CORRUPTION,
                        false,
                    )?
                    .visit_field::<flatbuffers::ForwardsUOffset<
                        flatbuffers::Vector<
                            '_,
                            flatbuffers::ForwardsUOffset<InfluentialIndividualState>,
                        >,
                    >>("influencers", Self::VT_INFLUENCERS, false)?
                    .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u32>>>(
                        "removedInfluencers",
                        Self::VT_REMOVEDINFLUENCERS,
                        false,
                    )?
                    .visit_field::<flatbuffers::ForwardsUOffset<TerrainOverlay>>(
                        "terrainOverlay",
                        Self::VT_TERRAINOVERLAY,
                        false,
                    )?
                    .visit_field::<flatbuffers::ForwardsUOffset<
                        flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<CultureLayerState>>,
                    >>("cultureLayers", Self::VT_CULTURELAYERS, false)?
                    .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u32>>>(
                        "removedCultureLayers",
                        Self::VT_REMOVEDCULTURELAYERS,
                        false,
                    )?
                    .visit_field::<flatbuffers::ForwardsUOffset<
                        flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<CultureTensionState>>,
                    >>("cultureTensions", Self::VT_CULTURETENSIONS, false)?
                    .visit_field::<flatbuffers::ForwardsUOffset<
                        flatbuffers::Vector<
                            '_,
                            flatbuffers::ForwardsUOffset<DiscoveryProgressEntry>,
                        >,
                    >>("discoveryProgress", Self::VT_DISCOVERYPROGRESS, false)?
                    .finish();
                Ok(())
            }
        }
        pub struct WorldDeltaArgs<'a> {
            pub header: Option<flatbuffers::WIPOffset<SnapshotHeader<'a>>>,
            pub tiles: Option<
                flatbuffers::WIPOffset<
                    flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<TileState<'a>>>,
                >,
            >,
            pub removedTiles: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u64>>>,
            pub logistics: Option<
                flatbuffers::WIPOffset<
                    flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<LogisticsLinkState<'a>>>,
                >,
            >,
            pub removedLogistics: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u64>>>,
            pub tradeLinks: Option<
                flatbuffers::WIPOffset<
                    flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<TradeLinkState<'a>>>,
                >,
            >,
            pub removedTradeLinks: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u64>>>,
            pub populations: Option<
                flatbuffers::WIPOffset<
                    flatbuffers::Vector<
                        'a,
                        flatbuffers::ForwardsUOffset<PopulationCohortState<'a>>,
                    >,
                >,
            >,
            pub removedPopulations: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u64>>>,
            pub power: Option<
                flatbuffers::WIPOffset<
                    flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<PowerNodeState<'a>>>,
                >,
            >,
            pub removedPower: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u64>>>,
            pub axisBias: Option<flatbuffers::WIPOffset<AxisBiasState<'a>>>,
            pub sentiment: Option<flatbuffers::WIPOffset<SentimentTelemetryState<'a>>>,
            pub generations: Option<
                flatbuffers::WIPOffset<
                    flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<GenerationState<'a>>>,
                >,
            >,
            pub removedGenerations: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u16>>>,
            pub corruption: Option<flatbuffers::WIPOffset<CorruptionLedger<'a>>>,
            pub influencers: Option<
                flatbuffers::WIPOffset<
                    flatbuffers::Vector<
                        'a,
                        flatbuffers::ForwardsUOffset<InfluentialIndividualState<'a>>,
                    >,
                >,
            >,
            pub removedInfluencers: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u32>>>,
            pub terrainOverlay: Option<flatbuffers::WIPOffset<TerrainOverlay<'a>>>,
            pub cultureLayers: Option<
                flatbuffers::WIPOffset<
                    flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<CultureLayerState<'a>>>,
                >,
            >,
            pub removedCultureLayers: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u32>>>,
            pub cultureTensions: Option<
                flatbuffers::WIPOffset<
                    flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<CultureTensionState<'a>>>,
                >,
            >,
            pub discoveryProgress: Option<
                flatbuffers::WIPOffset<
                    flatbuffers::Vector<
                        'a,
                        flatbuffers::ForwardsUOffset<DiscoveryProgressEntry<'a>>,
                    >,
                >,
            >,
        }
        impl<'a> Default for WorldDeltaArgs<'a> {
            #[inline]
            fn default() -> Self {
                WorldDeltaArgs {
                    header: None,
                    tiles: None,
                    removedTiles: None,
                    logistics: None,
                    removedLogistics: None,
                    tradeLinks: None,
                    removedTradeLinks: None,
                    populations: None,
                    removedPopulations: None,
                    power: None,
                    removedPower: None,
                    axisBias: None,
                    sentiment: None,
                    generations: None,
                    removedGenerations: None,
                    corruption: None,
                    influencers: None,
                    removedInfluencers: None,
                    terrainOverlay: None,
                    cultureLayers: None,
                    removedCultureLayers: None,
                    cultureTensions: None,
                    discoveryProgress: None,
                }
            }
        }

        pub struct WorldDeltaBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> WorldDeltaBuilder<'a, 'b, A> {
            #[inline]
            pub fn add_header(&mut self, header: flatbuffers::WIPOffset<SnapshotHeader<'b>>) {
                self.fbb_
                    .push_slot_always::<flatbuffers::WIPOffset<SnapshotHeader>>(
                        WorldDelta::VT_HEADER,
                        header,
                    );
            }
            #[inline]
            pub fn add_tiles(
                &mut self,
                tiles: flatbuffers::WIPOffset<
                    flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<TileState<'b>>>,
                >,
            ) {
                self.fbb_
                    .push_slot_always::<flatbuffers::WIPOffset<_>>(WorldDelta::VT_TILES, tiles);
            }
            #[inline]
            pub fn add_removedTiles(
                &mut self,
                removedTiles: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u64>>,
            ) {
                self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                    WorldDelta::VT_REMOVEDTILES,
                    removedTiles,
                );
            }
            #[inline]
            pub fn add_logistics(
                &mut self,
                logistics: flatbuffers::WIPOffset<
                    flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<LogisticsLinkState<'b>>>,
                >,
            ) {
                self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                    WorldDelta::VT_LOGISTICS,
                    logistics,
                );
            }
            #[inline]
            pub fn add_removedLogistics(
                &mut self,
                removedLogistics: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u64>>,
            ) {
                self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                    WorldDelta::VT_REMOVEDLOGISTICS,
                    removedLogistics,
                );
            }
            #[inline]
            pub fn add_tradeLinks(
                &mut self,
                tradeLinks: flatbuffers::WIPOffset<
                    flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<TradeLinkState<'b>>>,
                >,
            ) {
                self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                    WorldDelta::VT_TRADELINKS,
                    tradeLinks,
                );
            }
            #[inline]
            pub fn add_removedTradeLinks(
                &mut self,
                removedTradeLinks: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u64>>,
            ) {
                self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                    WorldDelta::VT_REMOVEDTRADELINKS,
                    removedTradeLinks,
                );
            }
            #[inline]
            pub fn add_populations(
                &mut self,
                populations: flatbuffers::WIPOffset<
                    flatbuffers::Vector<
                        'b,
                        flatbuffers::ForwardsUOffset<PopulationCohortState<'b>>,
                    >,
                >,
            ) {
                self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                    WorldDelta::VT_POPULATIONS,
                    populations,
                );
            }
            #[inline]
            pub fn add_removedPopulations(
                &mut self,
                removedPopulations: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u64>>,
            ) {
                self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                    WorldDelta::VT_REMOVEDPOPULATIONS,
                    removedPopulations,
                );
            }
            #[inline]
            pub fn add_power(
                &mut self,
                power: flatbuffers::WIPOffset<
                    flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<PowerNodeState<'b>>>,
                >,
            ) {
                self.fbb_
                    .push_slot_always::<flatbuffers::WIPOffset<_>>(WorldDelta::VT_POWER, power);
            }
            #[inline]
            pub fn add_removedPower(
                &mut self,
                removedPower: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u64>>,
            ) {
                self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                    WorldDelta::VT_REMOVEDPOWER,
                    removedPower,
                );
            }
            #[inline]
            pub fn add_axisBias(&mut self, axisBias: flatbuffers::WIPOffset<AxisBiasState<'b>>) {
                self.fbb_
                    .push_slot_always::<flatbuffers::WIPOffset<AxisBiasState>>(
                        WorldDelta::VT_AXISBIAS,
                        axisBias,
                    );
            }
            #[inline]
            pub fn add_sentiment(
                &mut self,
                sentiment: flatbuffers::WIPOffset<SentimentTelemetryState<'b>>,
            ) {
                self.fbb_
                    .push_slot_always::<flatbuffers::WIPOffset<SentimentTelemetryState>>(
                        WorldDelta::VT_SENTIMENT,
                        sentiment,
                    );
            }
            #[inline]
            pub fn add_generations(
                &mut self,
                generations: flatbuffers::WIPOffset<
                    flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<GenerationState<'b>>>,
                >,
            ) {
                self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                    WorldDelta::VT_GENERATIONS,
                    generations,
                );
            }
            #[inline]
            pub fn add_removedGenerations(
                &mut self,
                removedGenerations: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u16>>,
            ) {
                self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                    WorldDelta::VT_REMOVEDGENERATIONS,
                    removedGenerations,
                );
            }
            #[inline]
            pub fn add_corruption(
                &mut self,
                corruption: flatbuffers::WIPOffset<CorruptionLedger<'b>>,
            ) {
                self.fbb_
                    .push_slot_always::<flatbuffers::WIPOffset<CorruptionLedger>>(
                        WorldDelta::VT_CORRUPTION,
                        corruption,
                    );
            }
            #[inline]
            pub fn add_influencers(
                &mut self,
                influencers: flatbuffers::WIPOffset<
                    flatbuffers::Vector<
                        'b,
                        flatbuffers::ForwardsUOffset<InfluentialIndividualState<'b>>,
                    >,
                >,
            ) {
                self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                    WorldDelta::VT_INFLUENCERS,
                    influencers,
                );
            }
            #[inline]
            pub fn add_removedInfluencers(
                &mut self,
                removedInfluencers: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u32>>,
            ) {
                self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                    WorldDelta::VT_REMOVEDINFLUENCERS,
                    removedInfluencers,
                );
            }
            #[inline]
            pub fn add_terrainOverlay(
                &mut self,
                terrainOverlay: flatbuffers::WIPOffset<TerrainOverlay<'b>>,
            ) {
                self.fbb_
                    .push_slot_always::<flatbuffers::WIPOffset<TerrainOverlay>>(
                        WorldDelta::VT_TERRAINOVERLAY,
                        terrainOverlay,
                    );
            }
            #[inline]
            pub fn add_cultureLayers(
                &mut self,
                cultureLayers: flatbuffers::WIPOffset<
                    flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<CultureLayerState<'b>>>,
                >,
            ) {
                self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                    WorldDelta::VT_CULTURELAYERS,
                    cultureLayers,
                );
            }
            #[inline]
            pub fn add_removedCultureLayers(
                &mut self,
                removedCultureLayers: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u32>>,
            ) {
                self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                    WorldDelta::VT_REMOVEDCULTURELAYERS,
                    removedCultureLayers,
                );
            }
            #[inline]
            pub fn add_cultureTensions(
                &mut self,
                cultureTensions: flatbuffers::WIPOffset<
                    flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<CultureTensionState<'b>>>,
                >,
            ) {
                self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                    WorldDelta::VT_CULTURETENSIONS,
                    cultureTensions,
                );
            }
            #[inline]
            pub fn add_discoveryProgress(
                &mut self,
                discoveryProgress: flatbuffers::WIPOffset<
                    flatbuffers::Vector<
                        'b,
                        flatbuffers::ForwardsUOffset<DiscoveryProgressEntry<'b>>,
                    >,
                >,
            ) {
                self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                    WorldDelta::VT_DISCOVERYPROGRESS,
                    discoveryProgress,
                );
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
            ) -> WorldDeltaBuilder<'a, 'b, A> {
                let start = _fbb.start_table();
                WorldDeltaBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<WorldDelta<'a>> {
                let o = self.fbb_.end_table(self.start_);
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        impl core::fmt::Debug for WorldDelta<'_> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                let mut ds = f.debug_struct("WorldDelta");
                ds.field("header", &self.header());
                ds.field("tiles", &self.tiles());
                ds.field("removedTiles", &self.removedTiles());
                ds.field("logistics", &self.logistics());
                ds.field("removedLogistics", &self.removedLogistics());
                ds.field("tradeLinks", &self.tradeLinks());
                ds.field("removedTradeLinks", &self.removedTradeLinks());
                ds.field("populations", &self.populations());
                ds.field("removedPopulations", &self.removedPopulations());
                ds.field("power", &self.power());
                ds.field("removedPower", &self.removedPower());
                ds.field("axisBias", &self.axisBias());
                ds.field("sentiment", &self.sentiment());
                ds.field("generations", &self.generations());
                ds.field("removedGenerations", &self.removedGenerations());
                ds.field("corruption", &self.corruption());
                ds.field("influencers", &self.influencers());
                ds.field("removedInfluencers", &self.removedInfluencers());
                ds.field("terrainOverlay", &self.terrainOverlay());
                ds.field("cultureLayers", &self.cultureLayers());
                ds.field("removedCultureLayers", &self.removedCultureLayers());
                ds.field("cultureTensions", &self.cultureTensions());
                ds.field("discoveryProgress", &self.discoveryProgress());
                ds.finish()
            }
        }
        pub enum EnvelopeOffset {}
        #[derive(Copy, Clone, PartialEq)]

        pub struct Envelope<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for Envelope<'a> {
            type Inner = Envelope<'a>;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: unsafe { flatbuffers::Table::new(buf, loc) },
                }
            }
        }

        impl<'a> Envelope<'a> {
            pub const VT_PAYLOAD_TYPE: flatbuffers::VOffsetT = 4;
            pub const VT_PAYLOAD: flatbuffers::VOffsetT = 6;

            #[inline]
            pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                Envelope { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<
                'bldr: 'args,
                'args: 'mut_bldr,
                'mut_bldr,
                A: flatbuffers::Allocator + 'bldr,
            >(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
                args: &'args EnvelopeArgs,
            ) -> flatbuffers::WIPOffset<Envelope<'bldr>> {
                let mut builder = EnvelopeBuilder::new(_fbb);
                if let Some(x) = args.payload {
                    builder.add_payload(x);
                }
                builder.add_payload_type(args.payload_type);
                builder.finish()
            }

            #[inline]
            pub fn payload_type(&self) -> SnapshotPayload {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<SnapshotPayload>(
                            Envelope::VT_PAYLOAD_TYPE,
                            Some(SnapshotPayload::NONE),
                        )
                        .unwrap()
                }
            }
            #[inline]
            pub fn payload(&self) -> Option<flatbuffers::Table<'a>> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
                            Envelope::VT_PAYLOAD,
                            None,
                        )
                }
            }
            #[inline]
            #[allow(non_snake_case)]
            pub fn payload_as_snapshot(&self) -> Option<WorldSnapshot<'a>> {
                if self.payload_type() == SnapshotPayload::snapshot {
                    self.payload().map(|t| {
                        // Safety:
                        // Created from a valid Table for this object
                        // Which contains a valid union in this slot
                        unsafe { WorldSnapshot::init_from_table(t) }
                    })
                } else {
                    None
                }
            }

            #[inline]
            #[allow(non_snake_case)]
            pub fn payload_as_delta(&self) -> Option<WorldDelta<'a>> {
                if self.payload_type() == SnapshotPayload::delta {
                    self.payload().map(|t| {
                        // Safety:
                        // Created from a valid Table for this object
                        // Which contains a valid union in this slot
                        unsafe { WorldDelta::init_from_table(t) }
                    })
                } else {
                    None
                }
            }
        }

        impl flatbuffers::Verifiable for Envelope<'_> {
            #[inline]
            fn run_verifier(
                v: &mut flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                v.visit_table(pos)?
     .visit_union::<SnapshotPayload, _>("payload_type", Self::VT_PAYLOAD_TYPE, "payload", Self::VT_PAYLOAD, false, |key, v, pos| {
        match key {
          SnapshotPayload::snapshot => v.verify_union_variant::<flatbuffers::ForwardsUOffset<WorldSnapshot>>("SnapshotPayload::snapshot", pos),
          SnapshotPayload::delta => v.verify_union_variant::<flatbuffers::ForwardsUOffset<WorldDelta>>("SnapshotPayload::delta", pos),
          _ => Ok(()),
        }
     })?
     .finish();
                Ok(())
            }
        }
        pub struct EnvelopeArgs {
            pub payload_type: SnapshotPayload,
            pub payload: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
        }
        impl<'a> Default for EnvelopeArgs {
            #[inline]
            fn default() -> Self {
                EnvelopeArgs {
                    payload_type: SnapshotPayload::NONE,
                    payload: None,
                }
            }
        }

        pub struct EnvelopeBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> EnvelopeBuilder<'a, 'b, A> {
            #[inline]
            pub fn add_payload_type(&mut self, payload_type: SnapshotPayload) {
                self.fbb_.push_slot::<SnapshotPayload>(
                    Envelope::VT_PAYLOAD_TYPE,
                    payload_type,
                    SnapshotPayload::NONE,
                );
            }
            #[inline]
            pub fn add_payload(
                &mut self,
                payload: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>,
            ) {
                self.fbb_
                    .push_slot_always::<flatbuffers::WIPOffset<_>>(Envelope::VT_PAYLOAD, payload);
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
            ) -> EnvelopeBuilder<'a, 'b, A> {
                let start = _fbb.start_table();
                EnvelopeBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<Envelope<'a>> {
                let o = self.fbb_.end_table(self.start_);
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        impl core::fmt::Debug for Envelope<'_> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                let mut ds = f.debug_struct("Envelope");
                ds.field("payload_type", &self.payload_type());
                match self.payload_type() {
                    SnapshotPayload::snapshot => {
                        if let Some(x) = self.payload_as_snapshot() {
                            ds.field("payload", &x)
                        } else {
                            ds.field(
                                "payload",
                                &"InvalidFlatbuffer: Union discriminant does not match value.",
                            )
                        }
                    }
                    SnapshotPayload::delta => {
                        if let Some(x) = self.payload_as_delta() {
                            ds.field("payload", &x)
                        } else {
                            ds.field(
                                "payload",
                                &"InvalidFlatbuffer: Union discriminant does not match value.",
                            )
                        }
                    }
                    _ => {
                        let x: Option<()> = None;
                        ds.field("payload", &x)
                    }
                };
                ds.finish()
            }
        }
        #[inline]
        /// Verifies that a buffer of bytes contains a `Envelope`
        /// and returns it.
        /// Note that verification is still experimental and may not
        /// catch every error, or be maximally performant. For the
        /// previous, unchecked, behavior use
        /// `root_as_envelope_unchecked`.
        pub fn root_as_envelope(buf: &[u8]) -> Result<Envelope, flatbuffers::InvalidFlatbuffer> {
            flatbuffers::root::<Envelope>(buf)
        }
        #[inline]
        /// Verifies that a buffer of bytes contains a size prefixed
        /// `Envelope` and returns it.
        /// Note that verification is still experimental and may not
        /// catch every error, or be maximally performant. For the
        /// previous, unchecked, behavior use
        /// `size_prefixed_root_as_envelope_unchecked`.
        pub fn size_prefixed_root_as_envelope(
            buf: &[u8],
        ) -> Result<Envelope, flatbuffers::InvalidFlatbuffer> {
            flatbuffers::size_prefixed_root::<Envelope>(buf)
        }
        #[inline]
        /// Verifies, with the given options, that a buffer of bytes
        /// contains a `Envelope` and returns it.
        /// Note that verification is still experimental and may not
        /// catch every error, or be maximally performant. For the
        /// previous, unchecked, behavior use
        /// `root_as_envelope_unchecked`.
        pub fn root_as_envelope_with_opts<'b, 'o>(
            opts: &'o flatbuffers::VerifierOptions,
            buf: &'b [u8],
        ) -> Result<Envelope<'b>, flatbuffers::InvalidFlatbuffer> {
            flatbuffers::root_with_opts::<Envelope<'b>>(opts, buf)
        }
        #[inline]
        /// Verifies, with the given verifier options, that a buffer of
        /// bytes contains a size prefixed `Envelope` and returns
        /// it. Note that verification is still experimental and may not
        /// catch every error, or be maximally performant. For the
        /// previous, unchecked, behavior use
        /// `root_as_envelope_unchecked`.
        pub fn size_prefixed_root_as_envelope_with_opts<'b, 'o>(
            opts: &'o flatbuffers::VerifierOptions,
            buf: &'b [u8],
        ) -> Result<Envelope<'b>, flatbuffers::InvalidFlatbuffer> {
            flatbuffers::size_prefixed_root_with_opts::<Envelope<'b>>(opts, buf)
        }
        #[inline]
        /// Assumes, without verification, that a buffer of bytes contains a Envelope and returns it.
        /// # Safety
        /// Callers must trust the given bytes do indeed contain a valid `Envelope`.
        pub unsafe fn root_as_envelope_unchecked(buf: &[u8]) -> Envelope {
            unsafe { flatbuffers::root_unchecked::<Envelope>(buf) }
        }
        #[inline]
        /// Assumes, without verification, that a buffer of bytes contains a size prefixed Envelope and returns it.
        /// # Safety
        /// Callers must trust the given bytes do indeed contain a valid size prefixed `Envelope`.
        pub unsafe fn size_prefixed_root_as_envelope_unchecked(buf: &[u8]) -> Envelope {
            unsafe { flatbuffers::size_prefixed_root_unchecked::<Envelope>(buf) }
        }
        #[inline]
        pub fn finish_envelope_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(
            fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
            root: flatbuffers::WIPOffset<Envelope<'a>>,
        ) {
            fbb.finish(root, None);
        }

        #[inline]
        pub fn finish_size_prefixed_envelope_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(
            fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
            root: flatbuffers::WIPOffset<Envelope<'a>>,
        ) {
            fbb.finish_size_prefixed(root, None);
        }
    } // pub mod sim
} // pub mod shadow_scale
